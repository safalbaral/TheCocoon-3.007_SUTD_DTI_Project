import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM,
  _global,
  import_buffer,
  import_process,
  init_shim,
  require_buffer
} from "./chunk-Y37MGS27.js";

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    init_shim();
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    module.exports = EventEmitter;
    module.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++)
        args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve2, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve2([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/xtend/immutable.js
var require_immutable = __commonJS({
  "node_modules/xtend/immutable.js"(exports, module) {
    init_shim();
    module.exports = extend;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
    init_shim();
    module.exports = require_events().EventEmitter;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports, module) {
    "use strict";
    init_shim();
    var hasSymbols = require_shams();
    module.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    init_shim();
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    init_shim();
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push("$" + i);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    init_shim();
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/has/src/index.js
var require_src = __commonJS({
  "node_modules/has/src/index.js"(exports, module) {
    "use strict";
    init_shim();
    var bind = require_function_bind();
    module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    init_shim();
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = Object.getPrototypeOf || function(x) {
      return x.__proto__;
    };
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    try {
      null.error;
    } catch (e) {
      errorProto = getProto(getProto(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_src();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports, module) {
    "use strict";
    init_shim();
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module.exports = function callBind(originalFunction) {
      var func = $reflectApply(bind, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) {
          $defineProperty(
            func,
            "length",
            { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
          );
        }
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports, module) {
    "use strict";
    init_shim();
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// node_modules/is-arguments/index.js
var require_is_arguments = __commonJS({
  "node_modules/is-arguments/index.js"(exports, module) {
    "use strict";
    init_shim();
    var hasToStringTag = require_shams2()();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var isStandardArguments = function isArguments(value) {
      if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
        return false;
      }
      return $toString(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments(value) {
      if (isStandardArguments(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = function() {
      return isStandardArguments(arguments);
    }();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  }
});

// node_modules/is-generator-function/index.js
var require_is_generator_function = __commonJS({
  "node_modules/is-generator-function/index.js"(exports, module) {
    "use strict";
    init_shim();
    var toStr = Object.prototype.toString;
    var fnToStr = Function.prototype.toString;
    var isFnRegex = /^\s*(?:function)?\*/;
    var hasToStringTag = require_shams2()();
    var getProto = Object.getPrototypeOf;
    var getGeneratorFunc = function() {
      if (!hasToStringTag) {
        return false;
      }
      try {
        return Function("return function*() {}")();
      } catch (e) {
      }
    };
    var GeneratorFunction;
    module.exports = function isGeneratorFunction(fn) {
      if (typeof fn !== "function") {
        return false;
      }
      if (isFnRegex.test(fnToStr.call(fn))) {
        return true;
      }
      if (!hasToStringTag) {
        var str = toStr.call(fn);
        return str === "[object GeneratorFunction]";
      }
      if (!getProto) {
        return false;
      }
      if (typeof GeneratorFunction === "undefined") {
        var generatorFunc = getGeneratorFunc();
        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
      }
      return getProto(fn) === GeneratorFunction;
    };
  }
});

// node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "node_modules/is-callable/index.js"(exports, module) {
    "use strict";
    init_shim();
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_) {
        if (_ !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      all = document.all;
      if (toStr.call(all) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e) {
            }
          }
          return false;
        };
      }
    }
    var all;
    module.exports = reflectApply ? function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e) {
        if (e !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    };
  }
});

// node_modules/for-each/index.js
var require_for_each = __commonJS({
  "node_modules/for-each/index.js"(exports, module) {
    "use strict";
    init_shim();
    var isCallable = require_is_callable();
    var toStr = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var forEachArray = function forEachArray2(array, iterator, receiver) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
          if (receiver == null) {
            iterator(array[i], i, array);
          } else {
            iterator.call(receiver, array[i], i, array);
          }
        }
      }
    };
    var forEachString = function forEachString2(string, iterator, receiver) {
      for (var i = 0, len = string.length; i < len; i++) {
        if (receiver == null) {
          iterator(string.charAt(i), i, string);
        } else {
          iterator.call(receiver, string.charAt(i), i, string);
        }
      }
    };
    var forEachObject = function forEachObject2(object, iterator, receiver) {
      for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
          if (receiver == null) {
            iterator(object[k], k, object);
          } else {
            iterator.call(receiver, object[k], k, object);
          }
        }
      }
    };
    var forEach = function forEach2(list, iterator, thisArg) {
      if (!isCallable(iterator)) {
        throw new TypeError("iterator must be a function");
      }
      var receiver;
      if (arguments.length >= 3) {
        receiver = thisArg;
      }
      if (toStr.call(list) === "[object Array]") {
        forEachArray(list, iterator, receiver);
      } else if (typeof list === "string") {
        forEachString(list, iterator, receiver);
      } else {
        forEachObject(list, iterator, receiver);
      }
    };
    module.exports = forEach;
  }
});

// node_modules/available-typed-arrays/index.js
var require_available_typed_arrays = __commonJS({
  "node_modules/available-typed-arrays/index.js"(exports, module) {
    "use strict";
    init_shim();
    var possibleNames = [
      "BigInt64Array",
      "BigUint64Array",
      "Float32Array",
      "Float64Array",
      "Int16Array",
      "Int32Array",
      "Int8Array",
      "Uint16Array",
      "Uint32Array",
      "Uint8Array",
      "Uint8ClampedArray"
    ];
    var g = typeof globalThis === "undefined" ? _global : globalThis;
    module.exports = function availableTypedArrays() {
      var out = [];
      for (var i = 0; i < possibleNames.length; i++) {
        if (typeof g[possibleNames[i]] === "function") {
          out[out.length] = possibleNames[i];
        }
      }
      return out;
    };
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports, module) {
    "use strict";
    init_shim();
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// node_modules/is-typed-array/index.js
var require_is_typed_array = __commonJS({
  "node_modules/is-typed-array/index.js"(exports, module) {
    "use strict";
    init_shim();
    var forEach = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var gOPD = require_gopd();
    var g = typeof globalThis === "undefined" ? _global : globalThis;
    var typedArrays = availableTypedArrays();
    var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
      for (var i = 0; i < array.length; i += 1) {
        if (array[i] === value) {
          return i;
        }
      }
      return -1;
    };
    var $slice = callBound("String.prototype.slice");
    var toStrTags = {};
    var getPrototypeOf = Object.getPrototypeOf;
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr) {
          var proto = getPrototypeOf(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor) {
            var superProto = getPrototypeOf(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          toStrTags[typedArray] = descriptor.get;
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var anyTrue = false;
      forEach(toStrTags, function(getter, typedArray) {
        if (!anyTrue) {
          try {
            anyTrue = getter.call(value) === typedArray;
          } catch (e) {
          }
        }
      });
      return anyTrue;
    };
    module.exports = function isTypedArray(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag || !(Symbol.toStringTag in value)) {
        var tag = $slice($toString(value), 8, -1);
        return $indexOf(typedArrays, tag) > -1;
      }
      if (!gOPD) {
        return false;
      }
      return tryTypedArrays(value);
    };
  }
});

// node_modules/which-typed-array/index.js
var require_which_typed_array = __commonJS({
  "node_modules/which-typed-array/index.js"(exports, module) {
    "use strict";
    init_shim();
    var forEach = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBound = require_callBound();
    var gOPD = require_gopd();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g = typeof globalThis === "undefined" ? _global : globalThis;
    var typedArrays = availableTypedArrays();
    var $slice = callBound("String.prototype.slice");
    var toStrTags = {};
    var getPrototypeOf = Object.getPrototypeOf;
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach(typedArrays, function(typedArray) {
        if (typeof g[typedArray] === "function") {
          var arr = new g[typedArray]();
          if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf(proto);
              descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            toStrTags[typedArray] = descriptor.get;
          }
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var foundName = false;
      forEach(toStrTags, function(getter, typedArray) {
        if (!foundName) {
          try {
            var name = getter.call(value);
            if (name === typedArray) {
              foundName = name;
            }
          } catch (e) {
          }
        }
      });
      return foundName;
    };
    var isTypedArray = require_is_typed_array();
    module.exports = function whichTypedArray(value) {
      if (!isTypedArray(value)) {
        return false;
      }
      if (!hasToStringTag || !(Symbol.toStringTag in value)) {
        return $slice($toString(value), 8, -1);
      }
      return tryTypedArrays(value);
    };
  }
});

// node_modules/util/support/types.js
var require_types = __commonJS({
  "node_modules/util/support/types.js"(exports) {
    "use strict";
    init_shim();
    var isArgumentsObject = require_is_arguments();
    var isGeneratorFunction = require_is_generator_function();
    var whichTypedArray = require_which_typed_array();
    var isTypedArray = require_is_typed_array();
    function uncurryThis(f) {
      return f.call.bind(f);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    var bigIntValue;
    if (SymbolSupported) {
      symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    var symbolValue;
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e) {
        return false;
      }
    }
    exports.isArgumentsObject = isArgumentsObject;
    exports.isGeneratorFunction = isGeneratorFunction;
    exports.isTypedArray = isTypedArray;
    function isPromise(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports.isPromise = isPromise;
    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray(value) || isDataView(value);
    }
    exports.isArrayBufferView = isArrayBufferView;
    function isUint8Array(value) {
      return whichTypedArray(value) === "Uint8Array";
    }
    exports.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value) {
      return whichTypedArray(value) === "Uint8ClampedArray";
    }
    exports.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray(value) === "Uint16Array";
    }
    exports.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray(value) === "Uint32Array";
    }
    exports.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray(value) === "Int8Array";
    }
    exports.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray(value) === "Int16Array";
    }
    exports.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray(value) === "Int32Array";
    }
    exports.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray(value) === "Float32Array";
    }
    exports.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray(value) === "Float64Array";
    }
    exports.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray(value) === "BigInt64Array";
    }
    exports.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray(value) === "BigUint64Array";
    }
    exports.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
    }
    exports.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
  }
});

// node_modules/util/support/isBufferBrowser.js
var require_isBufferBrowser = __commonJS({
  "node_modules/util/support/isBufferBrowser.js"(exports, module) {
    init_shim();
    module.exports = function isBuffer(arg) {
      return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module) {
    init_shim();
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/util/util.js
var require_util = __commonJS({
  "node_modules/util/util.js"(exports) {
    init_shim();
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys = Object.keys(obj);
      var descriptors = {};
      for (var i = 0; i < keys.length; i++) {
        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports.format = function(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(" ");
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x2) {
        if (x2 === "%%")
          return "%";
        if (i >= len)
          return x2;
        switch (x2) {
          case "%s":
            return String(args[i++]);
          case "%d":
            return Number(args[i++]);
          case "%j":
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return "[Circular]";
            }
          default:
            return x2;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += " " + x;
        } else {
          str += " " + inspect(x);
        }
      }
      return str;
    };
    exports.deprecate = function(fn, msg) {
      if (typeof import_process.default !== "undefined" && import_process.default.noDeprecation === true) {
        return fn;
      }
      if (typeof import_process.default === "undefined") {
        return function() {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (import_process.default.throwDeprecation) {
            throw new Error(msg);
          } else if (import_process.default.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (import_process.default.env.NODE_DEBUG) {
      debugEnv = import_process.default.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    var debugEnv;
    exports.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid = import_process.default.pid;
          debugs[set] = function() {
            var msg = exports.format.apply(exports, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else {
          debugs[set] = function() {
          };
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3)
        ctx.depth = arguments[2];
      if (arguments.length >= 4)
        ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden))
        ctx.showHidden = false;
      if (isUndefined(ctx.depth))
        ctx.depth = 2;
      if (isUndefined(ctx.colors))
        ctx.colors = false;
      if (isUndefined(ctx.customInspect))
        ctx.customInspect = true;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function(val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name + "]", "special");
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = "", array = false, braces = ["{", "}"];
      if (isArray(value)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction(value)) {
        var n = value.name ? ": " + value.name : "";
        base = " [Function" + n + "]";
      }
      if (isRegExp(value)) {
        base = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = " " + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize("undefined", "undefined");
      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            String(i),
            true
          ));
        } else {
          output.push("");
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            key,
            true
          ));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = "[" + key + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").slice(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify("" + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.slice(1, -1);
          name = ctx.stylize(name, "name");
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, "string");
        }
      }
      return name + ": " + str;
    }
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf("\n") >= 0)
          numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base + " " + output.join(", ") + " " + braces[1];
    }
    exports.types = require_types();
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    exports.types.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === "[object Date]";
    }
    exports.isDate = isDate;
    exports.types.isDate = isDate;
    function isError(e) {
      return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
    }
    exports.isError = isError;
    exports.types.isNativeError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = require_isBufferBrowser();
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? "0" + n.toString(10) : n.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d = /* @__PURE__ */ new Date();
      var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
      ].join(":");
      return [d.getDate(), months[d.getMonth()], time].join(" ");
    }
    exports.log = function() {
      console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
    };
    exports.inherits = require_inherits_browser();
    exports._extend = function(origin, add) {
      if (!add || !isObject(add))
        return origin;
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    exports.promisify = function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }
      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve2, reject) {
          promiseResolve = resolve2;
          promiseReject = reject;
        });
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol)
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
      return Object.defineProperties(
        fn,
        getOwnPropertyDescriptors(original)
      );
    };
    exports.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this, args).then(
          function(ret) {
            import_process.default.nextTick(cb.bind(null, null, ret));
          },
          function(rej) {
            import_process.default.nextTick(callbackifyOnRejected.bind(null, rej, cb));
          }
        );
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(
        callbackified,
        getOwnPropertyDescriptors(original)
      );
      return callbackified;
    }
    exports.callbackify = callbackify;
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
    "use strict";
    init_shim();
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require_buffer();
    var Buffer2 = _require.Buffer;
    var _require2 = require_util();
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next)
            ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    init_shim();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            import_process.default.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            import_process.default.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            import_process.default.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            import_process.default.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          import_process.default.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          import_process.default.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/errors-browser.js
var require_errors_browser = __commonJS({
  "node_modules/readable-stream/errors-browser.js"(exports, module) {
    "use strict";
    init_shim();
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes = {};
    function createErrorType(code, message, Base2) {
      if (!Base2) {
        Base2 = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base2);
      NodeError.prototype.name = Base2.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
          return String(i);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module.exports.codes = codes;
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
    "use strict";
    init_shim();
    var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/util-deprecate/browser.js
var require_browser = __commonJS({
  "node_modules/util-deprecate/browser.js"(exports, module) {
    init_shim();
    module.exports = deprecate;
    function deprecate(fn, msg) {
      if (config("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config("throwDeprecation")) {
            throw new Error(msg);
          } else if (config("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config(name) {
      try {
        if (!_global.localStorage)
          return false;
      } catch (_) {
        return false;
      }
      var val = _global.localStorage[name];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_browser()
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_buffer().Buffer;
    var OurUint8Array = (typeof _global !== "undefined" ? _global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      import_process.default.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        import_process.default.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        import_process.default.nextTick(cb, er);
        import_process.default.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          import_process.default.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          import_process.default.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          import_process.default.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
    "use strict";
    init_shim();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj)
        keys2.push(key);
      return keys2;
    };
    module.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits_browser()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      import_process.default.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module) {
    init_shim();
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    init_shim();
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "�";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "�";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "�";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "�";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
    "use strict";
    init_shim();
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module.exports = eos;
  }
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
    "use strict";
    init_shim();
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve2 = iter[kLastResolve];
      if (resolve2 !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve2(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      import_process.default.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve2, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve2(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve2, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve2, reject) {
            import_process.default.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve2(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve2, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve2(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve2, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve2(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve2;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve2 = iterator[kLastResolve];
        if (resolve2 !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve2(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
    init_shim();
    module.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_buffer().Buffer;
    var OurUint8Array = (typeof _global !== "undefined" ? _global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require_util();
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits_browser()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        import_process.default.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        import_process.default.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== import_process.default.stdout && dest !== import_process.default.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        import_process.default.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            import_process.default.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        import_process.default.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        import_process.default.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        import_process.default.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        import_process.default.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from_browser();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Transform;
    var _require$codes = require_errors_browser().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits_browser()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits_browser()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
    "use strict";
    init_shim();
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors_browser().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop;
      if (typeof streams[streams.length - 1] !== "function")
        return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module.exports = pipeline;
  }
});

// node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "node_modules/readable-stream/readable-browser.js"(exports, module) {
    init_shim();
    exports = module.exports = require_stream_readable();
    exports.Stream = exports;
    exports.Readable = exports;
    exports.Writable = require_stream_writable();
    exports.Duplex = require_stream_duplex();
    exports.Transform = require_stream_transform();
    exports.PassThrough = require_stream_passthrough();
    exports.finished = require_end_of_stream();
    exports.pipeline = require_pipeline();
  }
});

// node_modules/mqtt/lib/store.js
var require_store = __commonJS({
  "node_modules/mqtt/lib/store.js"(exports, module) {
    "use strict";
    init_shim();
    var xtend = require_immutable();
    var Readable = require_readable_browser().Readable;
    var streamsOpts = { objectMode: true };
    var defaultStoreOptions = {
      clean: true
    };
    function Store(options) {
      if (!(this instanceof Store)) {
        return new Store(options);
      }
      this.options = options || {};
      this.options = xtend(defaultStoreOptions, options);
      this._inflights = /* @__PURE__ */ new Map();
    }
    Store.prototype.put = function(packet, cb) {
      this._inflights.set(packet.messageId, packet);
      if (cb) {
        cb();
      }
      return this;
    };
    Store.prototype.createStream = function() {
      const stream = new Readable(streamsOpts);
      const values = [];
      let destroyed = false;
      let i = 0;
      this._inflights.forEach(function(value, key) {
        values.push(value);
      });
      stream._read = function() {
        if (!destroyed && i < values.length) {
          this.push(values[i++]);
        } else {
          this.push(null);
        }
      };
      stream.destroy = function() {
        if (destroyed) {
          return;
        }
        const self2 = this;
        destroyed = true;
        setTimeout(function() {
          self2.emit("close");
        }, 0);
      };
      return stream;
    };
    Store.prototype.del = function(packet, cb) {
      packet = this._inflights.get(packet.messageId);
      if (packet) {
        this._inflights.delete(packet.messageId);
        cb(null, packet);
      } else if (cb) {
        cb(new Error("missing packet"));
      }
      return this;
    };
    Store.prototype.get = function(packet, cb) {
      packet = this._inflights.get(packet.messageId);
      if (packet) {
        cb(null, packet);
      } else if (cb) {
        cb(new Error("missing packet"));
      }
      return this;
    };
    Store.prototype.close = function(cb) {
      if (this.options.clean) {
        this._inflights = null;
      }
      if (cb) {
        cb();
      }
    };
    module.exports = Store;
  }
});

// node_modules/mqtt/lib/topic-alias-recv.js
var require_topic_alias_recv = __commonJS({
  "node_modules/mqtt/lib/topic-alias-recv.js"(exports, module) {
    "use strict";
    init_shim();
    function TopicAliasRecv(max) {
      if (!(this instanceof TopicAliasRecv)) {
        return new TopicAliasRecv(max);
      }
      this.aliasToTopic = {};
      this.max = max;
    }
    TopicAliasRecv.prototype.put = function(topic, alias) {
      if (alias === 0 || alias > this.max) {
        return false;
      }
      this.aliasToTopic[alias] = topic;
      this.length = Object.keys(this.aliasToTopic).length;
      return true;
    };
    TopicAliasRecv.prototype.getTopicByAlias = function(alias) {
      return this.aliasToTopic[alias];
    };
    TopicAliasRecv.prototype.clear = function() {
      this.aliasToTopic = {};
    };
    module.exports = TopicAliasRecv;
  }
});

// node_modules/mqtt/node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/mqtt/node_modules/yallist/iterator.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/mqtt/node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/mqtt/node_modules/yallist/yallist.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/mqtt/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/mqtt/node_modules/lru-cache/index.js"(exports, module) {
    "use strict";
    init_shim();
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      // resize the cache when the max changes.
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      // resize the cache when the lengthCalculator changes.
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module.exports = LRUCache;
  }
});

// node_modules/js-sdsl/dist/esm/container/ContainerBase/index.js
var __extends, ContainerIterator, Base, Container;
var init_ContainerBase = __esm({
  "node_modules/js-sdsl/dist/esm/container/ContainerBase/index.js"() {
    init_shim();
    __extends = function() {
      var extendStatics = function(n, t) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(n2, t2) {
          n2.__proto__ = t2;
        } || function(n2, t2) {
          for (var r in t2)
            if (Object.prototype.hasOwnProperty.call(t2, r))
              n2[r] = t2[r];
        };
        return extendStatics(n, t);
      };
      return function(n, t) {
        if (typeof t !== "function" && t !== null)
          throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
        extendStatics(n, t);
        function __() {
          this.constructor = n;
        }
        n.prototype = t === null ? Object.create(t) : (__.prototype = t.prototype, new __());
      };
    }();
    ContainerIterator = function() {
      function ContainerIterator2(n) {
        if (n === void 0) {
          n = 0;
        }
        this.iteratorType = n;
      }
      ContainerIterator2.prototype.equals = function(n) {
        return this.o === n.o;
      };
      return ContainerIterator2;
    }();
    Base = function() {
      function Base2() {
        this.M = 0;
      }
      Object.defineProperty(Base2.prototype, "length", {
        get: function() {
          return this.M;
        },
        enumerable: false,
        configurable: true
      });
      Base2.prototype.size = function() {
        return this.M;
      };
      Base2.prototype.empty = function() {
        return this.M === 0;
      };
      return Base2;
    }();
    Container = function(n) {
      __extends(Container2, n);
      function Container2() {
        return n !== null && n.apply(this, arguments) || this;
      }
      return Container2;
    }(Base);
  }
});

// node_modules/js-sdsl/dist/esm/container/OtherContainer/Stack.js
var __extends2, Stack, Stack_default;
var init_Stack = __esm({
  "node_modules/js-sdsl/dist/esm/container/OtherContainer/Stack.js"() {
    init_shim();
    init_ContainerBase();
    __extends2 = function() {
      var extendStatics = function(t, n) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(t2, n2) {
          t2.__proto__ = n2;
        } || function(t2, n2) {
          for (var i in n2)
            if (Object.prototype.hasOwnProperty.call(n2, i))
              t2[i] = n2[i];
        };
        return extendStatics(t, n);
      };
      return function(t, n) {
        if (typeof n !== "function" && n !== null)
          throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
        extendStatics(t, n);
        function __() {
          this.constructor = t;
        }
        t.prototype = n === null ? Object.create(n) : (__.prototype = n.prototype, new __());
      };
    }();
    Stack = function(t) {
      __extends2(Stack2, t);
      function Stack2(n) {
        if (n === void 0) {
          n = [];
        }
        var i = t.call(this) || this;
        i.nt = [];
        var r = i;
        n.forEach(function(t2) {
          r.push(t2);
        });
        return i;
      }
      Stack2.prototype.clear = function() {
        this.M = 0;
        this.nt = [];
      };
      Stack2.prototype.push = function(t2) {
        this.nt.push(t2);
        this.M += 1;
        return this.M;
      };
      Stack2.prototype.pop = function() {
        if (this.M === 0)
          return;
        this.M -= 1;
        return this.nt.pop();
      };
      Stack2.prototype.top = function() {
        return this.nt[this.M - 1];
      };
      return Stack2;
    }(Base);
    Stack_default = Stack;
  }
});

// node_modules/js-sdsl/dist/esm/container/OtherContainer/Queue.js
var __extends3, Queue, Queue_default;
var init_Queue = __esm({
  "node_modules/js-sdsl/dist/esm/container/OtherContainer/Queue.js"() {
    init_shim();
    init_ContainerBase();
    __extends3 = function() {
      var extendStatics = function(t, i) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(t2, i2) {
          t2.__proto__ = i2;
        } || function(t2, i2) {
          for (var n in i2)
            if (Object.prototype.hasOwnProperty.call(i2, n))
              t2[n] = i2[n];
        };
        return extendStatics(t, i);
      };
      return function(t, i) {
        if (typeof i !== "function" && i !== null)
          throw new TypeError("Class extends value " + String(i) + " is not a constructor or null");
        extendStatics(t, i);
        function __() {
          this.constructor = t;
        }
        t.prototype = i === null ? Object.create(i) : (__.prototype = i.prototype, new __());
      };
    }();
    Queue = function(t) {
      __extends3(Queue2, t);
      function Queue2(i) {
        if (i === void 0) {
          i = [];
        }
        var n = t.call(this) || this;
        n.A = 0;
        n.tt = [];
        var e = n;
        i.forEach(function(t2) {
          e.push(t2);
        });
        return n;
      }
      Queue2.prototype.clear = function() {
        this.tt = [];
        this.M = this.A = 0;
      };
      Queue2.prototype.push = function(t2) {
        var i = this.tt.length;
        if (this.A / i > 0.5 && this.A + this.M >= i && i > 4096) {
          var n = this.M;
          for (var e = 0; e < n; ++e) {
            this.tt[e] = this.tt[this.A + e];
          }
          this.A = 0;
          this.tt[this.M] = t2;
        } else
          this.tt[this.A + this.M] = t2;
        return ++this.M;
      };
      Queue2.prototype.pop = function() {
        if (this.M === 0)
          return;
        var t2 = this.tt[this.A++];
        this.M -= 1;
        return t2;
      };
      Queue2.prototype.front = function() {
        if (this.M === 0)
          return;
        return this.tt[this.A];
      };
      return Queue2;
    }(Base);
    Queue_default = Queue;
  }
});

// node_modules/js-sdsl/dist/esm/container/OtherContainer/PriorityQueue.js
var __extends4, __read, __spreadArray, PriorityQueue, PriorityQueue_default;
var init_PriorityQueue = __esm({
  "node_modules/js-sdsl/dist/esm/container/OtherContainer/PriorityQueue.js"() {
    init_shim();
    init_ContainerBase();
    __extends4 = function() {
      var extendStatics = function(i, r) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(i2, r2) {
          i2.__proto__ = r2;
        } || function(i2, r2) {
          for (var t in r2)
            if (Object.prototype.hasOwnProperty.call(r2, t))
              i2[t] = r2[t];
        };
        return extendStatics(i, r);
      };
      return function(i, r) {
        if (typeof r !== "function" && r !== null)
          throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
        extendStatics(i, r);
        function __() {
          this.constructor = i;
        }
        i.prototype = r === null ? Object.create(r) : (__.prototype = r.prototype, new __());
      };
    }();
    __read = function(i, r) {
      var t = typeof Symbol === "function" && i[Symbol.iterator];
      if (!t)
        return i;
      var e = t.call(i), n, u = [], s;
      try {
        while ((r === void 0 || r-- > 0) && !(n = e.next()).done)
          u.push(n.value);
      } catch (i2) {
        s = {
          error: i2
        };
      } finally {
        try {
          if (n && !n.done && (t = e["return"]))
            t.call(e);
        } finally {
          if (s)
            throw s.error;
        }
      }
      return u;
    };
    __spreadArray = function(i, r, t) {
      if (t || arguments.length === 2)
        for (var e = 0, n = r.length, u; e < n; e++) {
          if (u || !(e in r)) {
            if (!u)
              u = Array.prototype.slice.call(r, 0, e);
            u[e] = r[e];
          }
        }
      return i.concat(u || Array.prototype.slice.call(r));
    };
    PriorityQueue = function(i) {
      __extends4(PriorityQueue2, i);
      function PriorityQueue2(r, t, e) {
        if (r === void 0) {
          r = [];
        }
        if (t === void 0) {
          t = function(i2, r2) {
            if (i2 > r2)
              return -1;
            if (i2 < r2)
              return 1;
            return 0;
          };
        }
        if (e === void 0) {
          e = true;
        }
        var n = i.call(this) || this;
        n.$ = t;
        if (Array.isArray(r)) {
          n.ii = e ? __spreadArray([], __read(r), false) : r;
        } else {
          n.ii = [];
          var u = n;
          r.forEach(function(i2) {
            u.ii.push(i2);
          });
        }
        n.M = n.ii.length;
        var s = n.M >> 1;
        for (var o = n.M - 1 >> 1; o >= 0; --o) {
          n.ri(o, s);
        }
        return n;
      }
      PriorityQueue2.prototype.ti = function(i2) {
        var r = this.ii[i2];
        while (i2 > 0) {
          var t = i2 - 1 >> 1;
          var e = this.ii[t];
          if (this.$(e, r) <= 0)
            break;
          this.ii[i2] = e;
          i2 = t;
        }
        this.ii[i2] = r;
      };
      PriorityQueue2.prototype.ri = function(i2, r) {
        var t = this.ii[i2];
        while (i2 < r) {
          var e = i2 << 1 | 1;
          var n = e + 1;
          var u = this.ii[e];
          if (n < this.M && this.$(u, this.ii[n]) > 0) {
            e = n;
            u = this.ii[n];
          }
          if (this.$(u, t) >= 0)
            break;
          this.ii[i2] = u;
          i2 = e;
        }
        this.ii[i2] = t;
      };
      PriorityQueue2.prototype.clear = function() {
        this.M = 0;
        this.ii.length = 0;
      };
      PriorityQueue2.prototype.push = function(i2) {
        this.ii.push(i2);
        this.ti(this.M);
        this.M += 1;
      };
      PriorityQueue2.prototype.pop = function() {
        if (this.M === 0)
          return;
        var i2 = this.ii[0];
        var r = this.ii.pop();
        this.M -= 1;
        if (this.M) {
          this.ii[0] = r;
          this.ri(0, this.M >> 1);
        }
        return i2;
      };
      PriorityQueue2.prototype.top = function() {
        return this.ii[0];
      };
      PriorityQueue2.prototype.find = function(i2) {
        return this.ii.indexOf(i2) >= 0;
      };
      PriorityQueue2.prototype.remove = function(i2) {
        var r = this.ii.indexOf(i2);
        if (r < 0)
          return false;
        if (r === 0) {
          this.pop();
        } else if (r === this.M - 1) {
          this.ii.pop();
          this.M -= 1;
        } else {
          this.ii.splice(r, 1, this.ii.pop());
          this.M -= 1;
          this.ti(r);
          this.ri(r, this.M >> 1);
        }
        return true;
      };
      PriorityQueue2.prototype.updateItem = function(i2) {
        var r = this.ii.indexOf(i2);
        if (r < 0)
          return false;
        this.ti(r);
        this.ri(r, this.M >> 1);
        return true;
      };
      PriorityQueue2.prototype.toArray = function() {
        return __spreadArray([], __read(this.ii), false);
      };
      return PriorityQueue2;
    }(Base);
    PriorityQueue_default = PriorityQueue;
  }
});

// node_modules/js-sdsl/dist/esm/container/SequentialContainer/Base/index.js
var __extends5, SequentialContainer, Base_default;
var init_Base = __esm({
  "node_modules/js-sdsl/dist/esm/container/SequentialContainer/Base/index.js"() {
    init_shim();
    init_ContainerBase();
    __extends5 = function() {
      var extendStatics = function(n, t) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(n2, t2) {
          n2.__proto__ = t2;
        } || function(n2, t2) {
          for (var e in t2)
            if (Object.prototype.hasOwnProperty.call(t2, e))
              n2[e] = t2[e];
        };
        return extendStatics(n, t);
      };
      return function(n, t) {
        if (typeof t !== "function" && t !== null)
          throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
        extendStatics(n, t);
        function __() {
          this.constructor = n;
        }
        n.prototype = t === null ? Object.create(t) : (__.prototype = t.prototype, new __());
      };
    }();
    SequentialContainer = function(n) {
      __extends5(SequentialContainer2, n);
      function SequentialContainer2() {
        return n !== null && n.apply(this, arguments) || this;
      }
      return SequentialContainer2;
    }(Container);
    Base_default = SequentialContainer;
  }
});

// node_modules/js-sdsl/dist/esm/utils/throwError.js
function throwIteratorAccessError() {
  throw new RangeError("Iterator access denied!");
}
var init_throwError = __esm({
  "node_modules/js-sdsl/dist/esm/utils/throwError.js"() {
    init_shim();
  }
});

// node_modules/js-sdsl/dist/esm/container/SequentialContainer/Base/RandomIterator.js
var __extends6, RandomIterator;
var init_RandomIterator = __esm({
  "node_modules/js-sdsl/dist/esm/container/SequentialContainer/Base/RandomIterator.js"() {
    init_shim();
    init_ContainerBase();
    init_throwError();
    __extends6 = function() {
      var extendStatics = function(t, r) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(t2, r2) {
          t2.__proto__ = r2;
        } || function(t2, r2) {
          for (var n in r2)
            if (Object.prototype.hasOwnProperty.call(r2, n))
              t2[n] = r2[n];
        };
        return extendStatics(t, r);
      };
      return function(t, r) {
        if (typeof r !== "function" && r !== null)
          throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
        extendStatics(t, r);
        function __() {
          this.constructor = t;
        }
        t.prototype = r === null ? Object.create(r) : (__.prototype = r.prototype, new __());
      };
    }();
    RandomIterator = function(t) {
      __extends6(RandomIterator2, t);
      function RandomIterator2(r, n) {
        var o = t.call(this, n) || this;
        o.o = r;
        if (o.iteratorType === 0) {
          o.pre = function() {
            if (this.o === 0) {
              throwIteratorAccessError();
            }
            this.o -= 1;
            return this;
          };
          o.next = function() {
            if (this.o === this.container.size()) {
              throwIteratorAccessError();
            }
            this.o += 1;
            return this;
          };
        } else {
          o.pre = function() {
            if (this.o === this.container.size() - 1) {
              throwIteratorAccessError();
            }
            this.o += 1;
            return this;
          };
          o.next = function() {
            if (this.o === -1) {
              throwIteratorAccessError();
            }
            this.o -= 1;
            return this;
          };
        }
        return o;
      }
      Object.defineProperty(RandomIterator2.prototype, "pointer", {
        get: function() {
          return this.container.getElementByPos(this.o);
        },
        set: function(t2) {
          this.container.setElementByPos(this.o, t2);
        },
        enumerable: false,
        configurable: true
      });
      return RandomIterator2;
    }(ContainerIterator);
  }
});

// node_modules/js-sdsl/dist/esm/container/SequentialContainer/Vector.js
var __extends7, __generator, __read2, __spreadArray2, __values, VectorIterator, Vector, Vector_default;
var init_Vector = __esm({
  "node_modules/js-sdsl/dist/esm/container/SequentialContainer/Vector.js"() {
    init_shim();
    init_Base();
    init_RandomIterator();
    __extends7 = function() {
      var extendStatics = function(t, r) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(t2, r2) {
          t2.__proto__ = r2;
        } || function(t2, r2) {
          for (var e in r2)
            if (Object.prototype.hasOwnProperty.call(r2, e))
              t2[e] = r2[e];
        };
        return extendStatics(t, r);
      };
      return function(t, r) {
        if (typeof r !== "function" && r !== null)
          throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
        extendStatics(t, r);
        function __() {
          this.constructor = t;
        }
        t.prototype = r === null ? Object.create(r) : (__.prototype = r.prototype, new __());
      };
    }();
    __generator = function(t, r) {
      var e = {
        label: 0,
        sent: function() {
          if (o[0] & 1)
            throw o[1];
          return o[1];
        },
        trys: [],
        ops: []
      }, n, i, o, u;
      return u = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol === "function" && (u[Symbol.iterator] = function() {
        return this;
      }), u;
      function verb(t2) {
        return function(r2) {
          return step([t2, r2]);
        };
      }
      function step(u2) {
        if (n)
          throw new TypeError("Generator is already executing.");
        while (e)
          try {
            if (n = 1, i && (o = u2[0] & 2 ? i["return"] : u2[0] ? i["throw"] || ((o = i["return"]) && o.call(i), 0) : i.next) && !(o = o.call(i, u2[1])).done)
              return o;
            if (i = 0, o)
              u2 = [u2[0] & 2, o.value];
            switch (u2[0]) {
              case 0:
              case 1:
                o = u2;
                break;
              case 4:
                e.label++;
                return {
                  value: u2[1],
                  done: false
                };
              case 5:
                e.label++;
                i = u2[1];
                u2 = [0];
                continue;
              case 7:
                u2 = e.ops.pop();
                e.trys.pop();
                continue;
              default:
                if (!(o = e.trys, o = o.length > 0 && o[o.length - 1]) && (u2[0] === 6 || u2[0] === 2)) {
                  e = 0;
                  continue;
                }
                if (u2[0] === 3 && (!o || u2[1] > o[0] && u2[1] < o[3])) {
                  e.label = u2[1];
                  break;
                }
                if (u2[0] === 6 && e.label < o[1]) {
                  e.label = o[1];
                  o = u2;
                  break;
                }
                if (o && e.label < o[2]) {
                  e.label = o[2];
                  e.ops.push(u2);
                  break;
                }
                if (o[2])
                  e.ops.pop();
                e.trys.pop();
                continue;
            }
            u2 = r.call(t, e);
          } catch (t2) {
            u2 = [6, t2];
            i = 0;
          } finally {
            n = o = 0;
          }
        if (u2[0] & 5)
          throw u2[1];
        return {
          value: u2[0] ? u2[1] : void 0,
          done: true
        };
      }
    };
    __read2 = function(t, r) {
      var e = typeof Symbol === "function" && t[Symbol.iterator];
      if (!e)
        return t;
      var n = e.call(t), i, o = [], u;
      try {
        while ((r === void 0 || r-- > 0) && !(i = n.next()).done)
          o.push(i.value);
      } catch (t2) {
        u = {
          error: t2
        };
      } finally {
        try {
          if (i && !i.done && (e = n["return"]))
            e.call(n);
        } finally {
          if (u)
            throw u.error;
        }
      }
      return o;
    };
    __spreadArray2 = function(t, r, e) {
      if (e || arguments.length === 2)
        for (var n = 0, i = r.length, o; n < i; n++) {
          if (o || !(n in r)) {
            if (!o)
              o = Array.prototype.slice.call(r, 0, n);
            o[n] = r[n];
          }
        }
      return t.concat(o || Array.prototype.slice.call(r));
    };
    __values = function(t) {
      var r = typeof Symbol === "function" && Symbol.iterator, e = r && t[r], n = 0;
      if (e)
        return e.call(t);
      if (t && typeof t.length === "number")
        return {
          next: function() {
            if (t && n >= t.length)
              t = void 0;
            return {
              value: t && t[n++],
              done: !t
            };
          }
        };
      throw new TypeError(r ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    VectorIterator = function(t) {
      __extends7(VectorIterator2, t);
      function VectorIterator2(r, e, n) {
        var i = t.call(this, r, n) || this;
        i.container = e;
        return i;
      }
      VectorIterator2.prototype.copy = function() {
        return new VectorIterator2(this.o, this.container, this.iteratorType);
      };
      return VectorIterator2;
    }(RandomIterator);
    Vector = function(t) {
      __extends7(Vector2, t);
      function Vector2(r, e) {
        if (r === void 0) {
          r = [];
        }
        if (e === void 0) {
          e = true;
        }
        var n = t.call(this) || this;
        if (Array.isArray(r)) {
          n.J = e ? __spreadArray2([], __read2(r), false) : r;
          n.M = r.length;
        } else {
          n.J = [];
          var i = n;
          r.forEach(function(t2) {
            i.pushBack(t2);
          });
        }
        return n;
      }
      Vector2.prototype.clear = function() {
        this.M = 0;
        this.J.length = 0;
      };
      Vector2.prototype.begin = function() {
        return new VectorIterator(0, this);
      };
      Vector2.prototype.end = function() {
        return new VectorIterator(this.M, this);
      };
      Vector2.prototype.rBegin = function() {
        return new VectorIterator(this.M - 1, this, 1);
      };
      Vector2.prototype.rEnd = function() {
        return new VectorIterator(-1, this, 1);
      };
      Vector2.prototype.front = function() {
        return this.J[0];
      };
      Vector2.prototype.back = function() {
        return this.J[this.M - 1];
      };
      Vector2.prototype.getElementByPos = function(t2) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        return this.J[t2];
      };
      Vector2.prototype.eraseElementByPos = function(t2) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        this.J.splice(t2, 1);
        this.M -= 1;
        return this.M;
      };
      Vector2.prototype.eraseElementByValue = function(t2) {
        var r = 0;
        for (var e = 0; e < this.M; ++e) {
          if (this.J[e] !== t2) {
            this.J[r++] = this.J[e];
          }
        }
        this.M = this.J.length = r;
        return this.M;
      };
      Vector2.prototype.eraseElementByIterator = function(t2) {
        var r = t2.o;
        t2 = t2.next();
        this.eraseElementByPos(r);
        return t2;
      };
      Vector2.prototype.pushBack = function(t2) {
        this.J.push(t2);
        this.M += 1;
        return this.M;
      };
      Vector2.prototype.popBack = function() {
        if (this.M === 0)
          return;
        this.M -= 1;
        return this.J.pop();
      };
      Vector2.prototype.setElementByPos = function(t2, r) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        this.J[t2] = r;
      };
      Vector2.prototype.insert = function(t2, r, e) {
        var n;
        if (e === void 0) {
          e = 1;
        }
        if (t2 < 0 || t2 > this.M) {
          throw new RangeError();
        }
        (n = this.J).splice.apply(n, __spreadArray2([t2, 0], __read2(new Array(e).fill(r)), false));
        this.M += e;
        return this.M;
      };
      Vector2.prototype.find = function(t2) {
        for (var r = 0; r < this.M; ++r) {
          if (this.J[r] === t2) {
            return new VectorIterator(r, this);
          }
        }
        return this.end();
      };
      Vector2.prototype.reverse = function() {
        this.J.reverse();
      };
      Vector2.prototype.unique = function() {
        var t2 = 1;
        for (var r = 1; r < this.M; ++r) {
          if (this.J[r] !== this.J[r - 1]) {
            this.J[t2++] = this.J[r];
          }
        }
        this.M = this.J.length = t2;
        return this.M;
      };
      Vector2.prototype.sort = function(t2) {
        this.J.sort(t2);
      };
      Vector2.prototype.forEach = function(t2) {
        for (var r = 0; r < this.M; ++r) {
          t2(this.J[r], r, this);
        }
      };
      Vector2.prototype[Symbol.iterator] = function() {
        return function() {
          return __generator(this, function(t2) {
            switch (t2.label) {
              case 0:
                return [5, __values(this.J)];
              case 1:
                t2.sent();
                return [2];
            }
          });
        }.bind(this)();
      };
      return Vector2;
    }(Base_default);
    Vector_default = Vector;
  }
});

// node_modules/js-sdsl/dist/esm/container/SequentialContainer/LinkList.js
var __extends8, __generator2, LinkListIterator, LinkList, LinkList_default;
var init_LinkList = __esm({
  "node_modules/js-sdsl/dist/esm/container/SequentialContainer/LinkList.js"() {
    init_shim();
    init_Base();
    init_ContainerBase();
    init_throwError();
    __extends8 = function() {
      var extendStatics = function(t, i) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(t2, i2) {
          t2.__proto__ = i2;
        } || function(t2, i2) {
          for (var r in i2)
            if (Object.prototype.hasOwnProperty.call(i2, r))
              t2[r] = i2[r];
        };
        return extendStatics(t, i);
      };
      return function(t, i) {
        if (typeof i !== "function" && i !== null)
          throw new TypeError("Class extends value " + String(i) + " is not a constructor or null");
        extendStatics(t, i);
        function __() {
          this.constructor = t;
        }
        t.prototype = i === null ? Object.create(i) : (__.prototype = i.prototype, new __());
      };
    }();
    __generator2 = function(t, i) {
      var r = {
        label: 0,
        sent: function() {
          if (e[0] & 1)
            throw e[1];
          return e[1];
        },
        trys: [],
        ops: []
      }, n, s, e, h;
      return h = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol === "function" && (h[Symbol.iterator] = function() {
        return this;
      }), h;
      function verb(t2) {
        return function(i2) {
          return step([t2, i2]);
        };
      }
      function step(h2) {
        if (n)
          throw new TypeError("Generator is already executing.");
        while (r)
          try {
            if (n = 1, s && (e = h2[0] & 2 ? s["return"] : h2[0] ? s["throw"] || ((e = s["return"]) && e.call(s), 0) : s.next) && !(e = e.call(s, h2[1])).done)
              return e;
            if (s = 0, e)
              h2 = [h2[0] & 2, e.value];
            switch (h2[0]) {
              case 0:
              case 1:
                e = h2;
                break;
              case 4:
                r.label++;
                return {
                  value: h2[1],
                  done: false
                };
              case 5:
                r.label++;
                s = h2[1];
                h2 = [0];
                continue;
              case 7:
                h2 = r.ops.pop();
                r.trys.pop();
                continue;
              default:
                if (!(e = r.trys, e = e.length > 0 && e[e.length - 1]) && (h2[0] === 6 || h2[0] === 2)) {
                  r = 0;
                  continue;
                }
                if (h2[0] === 3 && (!e || h2[1] > e[0] && h2[1] < e[3])) {
                  r.label = h2[1];
                  break;
                }
                if (h2[0] === 6 && r.label < e[1]) {
                  r.label = e[1];
                  e = h2;
                  break;
                }
                if (e && r.label < e[2]) {
                  r.label = e[2];
                  r.ops.push(h2);
                  break;
                }
                if (e[2])
                  r.ops.pop();
                r.trys.pop();
                continue;
            }
            h2 = i.call(t, r);
          } catch (t2) {
            h2 = [6, t2];
            s = 0;
          } finally {
            n = e = 0;
          }
        if (h2[0] & 5)
          throw h2[1];
        return {
          value: h2[0] ? h2[1] : void 0,
          done: true
        };
      }
    };
    LinkListIterator = function(t) {
      __extends8(LinkListIterator2, t);
      function LinkListIterator2(i, r, n, s) {
        var e = t.call(this, s) || this;
        e.o = i;
        e.h = r;
        e.container = n;
        if (e.iteratorType === 0) {
          e.pre = function() {
            if (this.o.L === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.L;
            return this;
          };
          e.next = function() {
            if (this.o === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.m;
            return this;
          };
        } else {
          e.pre = function() {
            if (this.o.m === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.m;
            return this;
          };
          e.next = function() {
            if (this.o === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.L;
            return this;
          };
        }
        return e;
      }
      Object.defineProperty(LinkListIterator2.prototype, "pointer", {
        get: function() {
          if (this.o === this.h) {
            throwIteratorAccessError();
          }
          return this.o.p;
        },
        set: function(t2) {
          if (this.o === this.h) {
            throwIteratorAccessError();
          }
          this.o.p = t2;
        },
        enumerable: false,
        configurable: true
      });
      LinkListIterator2.prototype.copy = function() {
        return new LinkListIterator2(this.o, this.h, this.container, this.iteratorType);
      };
      return LinkListIterator2;
    }(ContainerIterator);
    LinkList = function(t) {
      __extends8(LinkList2, t);
      function LinkList2(i) {
        if (i === void 0) {
          i = [];
        }
        var r = t.call(this) || this;
        r.h = {};
        r.H = r.l = r.h.L = r.h.m = r.h;
        var n = r;
        i.forEach(function(t2) {
          n.pushBack(t2);
        });
        return r;
      }
      LinkList2.prototype.G = function(t2) {
        var i = t2.L, r = t2.m;
        i.m = r;
        r.L = i;
        if (t2 === this.H) {
          this.H = r;
        }
        if (t2 === this.l) {
          this.l = i;
        }
        this.M -= 1;
      };
      LinkList2.prototype.F = function(t2, i) {
        var r = i.m;
        var n = {
          p: t2,
          L: i,
          m: r
        };
        i.m = n;
        r.L = n;
        if (i === this.h) {
          this.H = n;
        }
        if (r === this.h) {
          this.l = n;
        }
        this.M += 1;
      };
      LinkList2.prototype.clear = function() {
        this.M = 0;
        this.H = this.l = this.h.L = this.h.m = this.h;
      };
      LinkList2.prototype.begin = function() {
        return new LinkListIterator(this.H, this.h, this);
      };
      LinkList2.prototype.end = function() {
        return new LinkListIterator(this.h, this.h, this);
      };
      LinkList2.prototype.rBegin = function() {
        return new LinkListIterator(this.l, this.h, this, 1);
      };
      LinkList2.prototype.rEnd = function() {
        return new LinkListIterator(this.h, this.h, this, 1);
      };
      LinkList2.prototype.front = function() {
        return this.H.p;
      };
      LinkList2.prototype.back = function() {
        return this.l.p;
      };
      LinkList2.prototype.getElementByPos = function(t2) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        var i = this.H;
        while (t2--) {
          i = i.m;
        }
        return i.p;
      };
      LinkList2.prototype.eraseElementByPos = function(t2) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        var i = this.H;
        while (t2--) {
          i = i.m;
        }
        this.G(i);
        return this.M;
      };
      LinkList2.prototype.eraseElementByValue = function(t2) {
        var i = this.H;
        while (i !== this.h) {
          if (i.p === t2) {
            this.G(i);
          }
          i = i.m;
        }
        return this.M;
      };
      LinkList2.prototype.eraseElementByIterator = function(t2) {
        var i = t2.o;
        if (i === this.h) {
          throwIteratorAccessError();
        }
        t2 = t2.next();
        this.G(i);
        return t2;
      };
      LinkList2.prototype.pushBack = function(t2) {
        this.F(t2, this.l);
        return this.M;
      };
      LinkList2.prototype.popBack = function() {
        if (this.M === 0)
          return;
        var t2 = this.l.p;
        this.G(this.l);
        return t2;
      };
      LinkList2.prototype.pushFront = function(t2) {
        this.F(t2, this.h);
        return this.M;
      };
      LinkList2.prototype.popFront = function() {
        if (this.M === 0)
          return;
        var t2 = this.H.p;
        this.G(this.H);
        return t2;
      };
      LinkList2.prototype.setElementByPos = function(t2, i) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        var r = this.H;
        while (t2--) {
          r = r.m;
        }
        r.p = i;
      };
      LinkList2.prototype.insert = function(t2, i, r) {
        if (r === void 0) {
          r = 1;
        }
        if (t2 < 0 || t2 > this.M) {
          throw new RangeError();
        }
        if (r <= 0)
          return this.M;
        if (t2 === 0) {
          while (r--)
            this.pushFront(i);
        } else if (t2 === this.M) {
          while (r--)
            this.pushBack(i);
        } else {
          var n = this.H;
          for (var s = 1; s < t2; ++s) {
            n = n.m;
          }
          var e = n.m;
          this.M += r;
          while (r--) {
            n.m = {
              p: i,
              L: n
            };
            n.m.L = n;
            n = n.m;
          }
          n.m = e;
          e.L = n;
        }
        return this.M;
      };
      LinkList2.prototype.find = function(t2) {
        var i = this.H;
        while (i !== this.h) {
          if (i.p === t2) {
            return new LinkListIterator(i, this.h, this);
          }
          i = i.m;
        }
        return this.end();
      };
      LinkList2.prototype.reverse = function() {
        if (this.M <= 1)
          return;
        var t2 = this.H;
        var i = this.l;
        var r = 0;
        while (r << 1 < this.M) {
          var n = t2.p;
          t2.p = i.p;
          i.p = n;
          t2 = t2.m;
          i = i.L;
          r += 1;
        }
      };
      LinkList2.prototype.unique = function() {
        if (this.M <= 1) {
          return this.M;
        }
        var t2 = this.H;
        while (t2 !== this.h) {
          var i = t2;
          while (i.m !== this.h && i.p === i.m.p) {
            i = i.m;
            this.M -= 1;
          }
          t2.m = i.m;
          t2.m.L = t2;
          t2 = t2.m;
        }
        return this.M;
      };
      LinkList2.prototype.sort = function(t2) {
        if (this.M <= 1)
          return;
        var i = [];
        this.forEach(function(t3) {
          i.push(t3);
        });
        i.sort(t2);
        var r = this.H;
        i.forEach(function(t3) {
          r.p = t3;
          r = r.m;
        });
      };
      LinkList2.prototype.merge = function(t2) {
        var i = this;
        if (this.M === 0) {
          t2.forEach(function(t3) {
            i.pushBack(t3);
          });
        } else {
          var r = this.H;
          t2.forEach(function(t3) {
            while (r !== i.h && r.p <= t3) {
              r = r.m;
            }
            i.F(t3, r.L);
          });
        }
        return this.M;
      };
      LinkList2.prototype.forEach = function(t2) {
        var i = this.H;
        var r = 0;
        while (i !== this.h) {
          t2(i.p, r++, this);
          i = i.m;
        }
      };
      LinkList2.prototype[Symbol.iterator] = function() {
        return function() {
          var t2;
          return __generator2(this, function(i) {
            switch (i.label) {
              case 0:
                if (this.M === 0)
                  return [2];
                t2 = this.H;
                i.label = 1;
              case 1:
                if (!(t2 !== this.h))
                  return [3, 3];
                return [4, t2.p];
              case 2:
                i.sent();
                t2 = t2.m;
                return [3, 1];
              case 3:
                return [2];
            }
          });
        }.bind(this)();
      };
      return LinkList2;
    }(Base_default);
    LinkList_default = LinkList;
  }
});

// node_modules/js-sdsl/dist/esm/container/SequentialContainer/Deque.js
var __extends9, __generator3, __read3, __spreadArray3, DequeIterator, Deque, Deque_default;
var init_Deque = __esm({
  "node_modules/js-sdsl/dist/esm/container/SequentialContainer/Deque.js"() {
    init_shim();
    init_Base();
    init_RandomIterator();
    __extends9 = function() {
      var extendStatics = function(t, i) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(t2, i2) {
          t2.__proto__ = i2;
        } || function(t2, i2) {
          for (var r in i2)
            if (Object.prototype.hasOwnProperty.call(i2, r))
              t2[r] = i2[r];
        };
        return extendStatics(t, i);
      };
      return function(t, i) {
        if (typeof i !== "function" && i !== null)
          throw new TypeError("Class extends value " + String(i) + " is not a constructor or null");
        extendStatics(t, i);
        function __() {
          this.constructor = t;
        }
        t.prototype = i === null ? Object.create(i) : (__.prototype = i.prototype, new __());
      };
    }();
    __generator3 = function(t, i) {
      var r = {
        label: 0,
        sent: function() {
          if (h[0] & 1)
            throw h[1];
          return h[1];
        },
        trys: [],
        ops: []
      }, e, s, h, n;
      return n = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol === "function" && (n[Symbol.iterator] = function() {
        return this;
      }), n;
      function verb(t2) {
        return function(i2) {
          return step([t2, i2]);
        };
      }
      function step(n2) {
        if (e)
          throw new TypeError("Generator is already executing.");
        while (r)
          try {
            if (e = 1, s && (h = n2[0] & 2 ? s["return"] : n2[0] ? s["throw"] || ((h = s["return"]) && h.call(s), 0) : s.next) && !(h = h.call(s, n2[1])).done)
              return h;
            if (s = 0, h)
              n2 = [n2[0] & 2, h.value];
            switch (n2[0]) {
              case 0:
              case 1:
                h = n2;
                break;
              case 4:
                r.label++;
                return {
                  value: n2[1],
                  done: false
                };
              case 5:
                r.label++;
                s = n2[1];
                n2 = [0];
                continue;
              case 7:
                n2 = r.ops.pop();
                r.trys.pop();
                continue;
              default:
                if (!(h = r.trys, h = h.length > 0 && h[h.length - 1]) && (n2[0] === 6 || n2[0] === 2)) {
                  r = 0;
                  continue;
                }
                if (n2[0] === 3 && (!h || n2[1] > h[0] && n2[1] < h[3])) {
                  r.label = n2[1];
                  break;
                }
                if (n2[0] === 6 && r.label < h[1]) {
                  r.label = h[1];
                  h = n2;
                  break;
                }
                if (h && r.label < h[2]) {
                  r.label = h[2];
                  r.ops.push(n2);
                  break;
                }
                if (h[2])
                  r.ops.pop();
                r.trys.pop();
                continue;
            }
            n2 = i.call(t, r);
          } catch (t2) {
            n2 = [6, t2];
            s = 0;
          } finally {
            e = h = 0;
          }
        if (n2[0] & 5)
          throw n2[1];
        return {
          value: n2[0] ? n2[1] : void 0,
          done: true
        };
      }
    };
    __read3 = function(t, i) {
      var r = typeof Symbol === "function" && t[Symbol.iterator];
      if (!r)
        return t;
      var e = r.call(t), s, h = [], n;
      try {
        while ((i === void 0 || i-- > 0) && !(s = e.next()).done)
          h.push(s.value);
      } catch (t2) {
        n = {
          error: t2
        };
      } finally {
        try {
          if (s && !s.done && (r = e["return"]))
            r.call(e);
        } finally {
          if (n)
            throw n.error;
        }
      }
      return h;
    };
    __spreadArray3 = function(t, i, r) {
      if (r || arguments.length === 2)
        for (var e = 0, s = i.length, h; e < s; e++) {
          if (h || !(e in i)) {
            if (!h)
              h = Array.prototype.slice.call(i, 0, e);
            h[e] = i[e];
          }
        }
      return t.concat(h || Array.prototype.slice.call(i));
    };
    DequeIterator = function(t) {
      __extends9(DequeIterator2, t);
      function DequeIterator2(i, r, e) {
        var s = t.call(this, i, e) || this;
        s.container = r;
        return s;
      }
      DequeIterator2.prototype.copy = function() {
        return new DequeIterator2(this.o, this.container, this.iteratorType);
      };
      return DequeIterator2;
    }(RandomIterator);
    Deque = function(t) {
      __extends9(Deque2, t);
      function Deque2(i, r) {
        if (i === void 0) {
          i = [];
        }
        if (r === void 0) {
          r = 1 << 12;
        }
        var e = t.call(this) || this;
        e.A = 0;
        e.S = 0;
        e.R = 0;
        e.k = 0;
        e.C = 0;
        e.j = [];
        var s = function() {
          if (typeof i.length === "number")
            return i.length;
          if (typeof i.size === "number")
            return i.size;
          if (typeof i.size === "function")
            return i.size();
          throw new TypeError("Cannot get the length or size of the container");
        }();
        e.B = r;
        e.C = Math.max(Math.ceil(s / e.B), 1);
        for (var h = 0; h < e.C; ++h) {
          e.j.push(new Array(e.B));
        }
        var n = Math.ceil(s / e.B);
        e.A = e.R = (e.C >> 1) - (n >> 1);
        e.S = e.k = e.B - s % e.B >> 1;
        var u = e;
        i.forEach(function(t2) {
          u.pushBack(t2);
        });
        return e;
      }
      Deque2.prototype.O = function() {
        var t2 = [];
        var i = Math.max(this.C >> 1, 1);
        for (var r = 0; r < i; ++r) {
          t2[r] = new Array(this.B);
        }
        for (var r = this.A; r < this.C; ++r) {
          t2[t2.length] = this.j[r];
        }
        for (var r = 0; r < this.R; ++r) {
          t2[t2.length] = this.j[r];
        }
        t2[t2.length] = __spreadArray3([], __read3(this.j[this.R]), false);
        this.A = i;
        this.R = t2.length - 1;
        for (var r = 0; r < i; ++r) {
          t2[t2.length] = new Array(this.B);
        }
        this.j = t2;
        this.C = t2.length;
      };
      Deque2.prototype.T = function(t2) {
        var i = this.S + t2 + 1;
        var r = i % this.B;
        var e = r - 1;
        var s = this.A + (i - r) / this.B;
        if (r === 0)
          s -= 1;
        s %= this.C;
        if (e < 0)
          e += this.B;
        return {
          curNodeBucketIndex: s,
          curNodePointerIndex: e
        };
      };
      Deque2.prototype.clear = function() {
        this.j = [new Array(this.B)];
        this.C = 1;
        this.A = this.R = this.M = 0;
        this.S = this.k = this.B >> 1;
      };
      Deque2.prototype.begin = function() {
        return new DequeIterator(0, this);
      };
      Deque2.prototype.end = function() {
        return new DequeIterator(this.M, this);
      };
      Deque2.prototype.rBegin = function() {
        return new DequeIterator(this.M - 1, this, 1);
      };
      Deque2.prototype.rEnd = function() {
        return new DequeIterator(-1, this, 1);
      };
      Deque2.prototype.front = function() {
        if (this.M === 0)
          return;
        return this.j[this.A][this.S];
      };
      Deque2.prototype.back = function() {
        if (this.M === 0)
          return;
        return this.j[this.R][this.k];
      };
      Deque2.prototype.pushBack = function(t2) {
        if (this.M) {
          if (this.k < this.B - 1) {
            this.k += 1;
          } else if (this.R < this.C - 1) {
            this.R += 1;
            this.k = 0;
          } else {
            this.R = 0;
            this.k = 0;
          }
          if (this.R === this.A && this.k === this.S)
            this.O();
        }
        this.M += 1;
        this.j[this.R][this.k] = t2;
        return this.M;
      };
      Deque2.prototype.popBack = function() {
        if (this.M === 0)
          return;
        var t2 = this.j[this.R][this.k];
        if (this.M !== 1) {
          if (this.k > 0) {
            this.k -= 1;
          } else if (this.R > 0) {
            this.R -= 1;
            this.k = this.B - 1;
          } else {
            this.R = this.C - 1;
            this.k = this.B - 1;
          }
        }
        this.M -= 1;
        return t2;
      };
      Deque2.prototype.pushFront = function(t2) {
        if (this.M) {
          if (this.S > 0) {
            this.S -= 1;
          } else if (this.A > 0) {
            this.A -= 1;
            this.S = this.B - 1;
          } else {
            this.A = this.C - 1;
            this.S = this.B - 1;
          }
          if (this.A === this.R && this.S === this.k)
            this.O();
        }
        this.M += 1;
        this.j[this.A][this.S] = t2;
        return this.M;
      };
      Deque2.prototype.popFront = function() {
        if (this.M === 0)
          return;
        var t2 = this.j[this.A][this.S];
        if (this.M !== 1) {
          if (this.S < this.B - 1) {
            this.S += 1;
          } else if (this.A < this.C - 1) {
            this.A += 1;
            this.S = 0;
          } else {
            this.A = 0;
            this.S = 0;
          }
        }
        this.M -= 1;
        return t2;
      };
      Deque2.prototype.getElementByPos = function(t2) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        var i = this.T(t2), r = i.curNodeBucketIndex, e = i.curNodePointerIndex;
        return this.j[r][e];
      };
      Deque2.prototype.setElementByPos = function(t2, i) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        var r = this.T(t2), e = r.curNodeBucketIndex, s = r.curNodePointerIndex;
        this.j[e][s] = i;
      };
      Deque2.prototype.insert = function(t2, i, r) {
        if (r === void 0) {
          r = 1;
        }
        if (t2 < 0 || t2 > this.M) {
          throw new RangeError();
        }
        if (t2 === 0) {
          while (r--)
            this.pushFront(i);
        } else if (t2 === this.M) {
          while (r--)
            this.pushBack(i);
        } else {
          var e = [];
          for (var s = t2; s < this.M; ++s) {
            e.push(this.getElementByPos(s));
          }
          this.cut(t2 - 1);
          for (var s = 0; s < r; ++s)
            this.pushBack(i);
          for (var s = 0; s < e.length; ++s)
            this.pushBack(e[s]);
        }
        return this.M;
      };
      Deque2.prototype.cut = function(t2) {
        if (t2 < 0) {
          this.clear();
          return 0;
        }
        var i = this.T(t2), r = i.curNodeBucketIndex, e = i.curNodePointerIndex;
        this.R = r;
        this.k = e;
        this.M = t2 + 1;
        return this.M;
      };
      Deque2.prototype.eraseElementByPos = function(t2) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        if (t2 === 0)
          this.popFront();
        else if (t2 === this.M - 1)
          this.popBack();
        else {
          var i = [];
          for (var r = t2 + 1; r < this.M; ++r) {
            i.push(this.getElementByPos(r));
          }
          this.cut(t2);
          this.popBack();
          var e = this;
          i.forEach(function(t3) {
            e.pushBack(t3);
          });
        }
        return this.M;
      };
      Deque2.prototype.eraseElementByValue = function(t2) {
        if (this.M === 0)
          return 0;
        var i = [];
        for (var r = 0; r < this.M; ++r) {
          var e = this.getElementByPos(r);
          if (e !== t2)
            i.push(e);
        }
        var s = i.length;
        for (var r = 0; r < s; ++r)
          this.setElementByPos(r, i[r]);
        return this.cut(s - 1);
      };
      Deque2.prototype.eraseElementByIterator = function(t2) {
        var i = t2.o;
        this.eraseElementByPos(i);
        t2 = t2.next();
        return t2;
      };
      Deque2.prototype.find = function(t2) {
        for (var i = 0; i < this.M; ++i) {
          if (this.getElementByPos(i) === t2) {
            return new DequeIterator(i, this);
          }
        }
        return this.end();
      };
      Deque2.prototype.reverse = function() {
        var t2 = 0;
        var i = this.M - 1;
        while (t2 < i) {
          var r = this.getElementByPos(t2);
          this.setElementByPos(t2, this.getElementByPos(i));
          this.setElementByPos(i, r);
          t2 += 1;
          i -= 1;
        }
      };
      Deque2.prototype.unique = function() {
        if (this.M <= 1) {
          return this.M;
        }
        var t2 = 1;
        var i = this.getElementByPos(0);
        for (var r = 1; r < this.M; ++r) {
          var e = this.getElementByPos(r);
          if (e !== i) {
            i = e;
            this.setElementByPos(t2++, e);
          }
        }
        while (this.M > t2)
          this.popBack();
        return this.M;
      };
      Deque2.prototype.sort = function(t2) {
        var i = [];
        for (var r = 0; r < this.M; ++r) {
          i.push(this.getElementByPos(r));
        }
        i.sort(t2);
        for (var r = 0; r < this.M; ++r)
          this.setElementByPos(r, i[r]);
      };
      Deque2.prototype.shrinkToFit = function() {
        if (this.M === 0)
          return;
        var t2 = [];
        this.forEach(function(i2) {
          t2.push(i2);
        });
        this.C = Math.max(Math.ceil(this.M / this.B), 1);
        this.M = this.A = this.R = this.S = this.k = 0;
        this.j = [];
        for (var i = 0; i < this.C; ++i) {
          this.j.push(new Array(this.B));
        }
        for (var i = 0; i < t2.length; ++i)
          this.pushBack(t2[i]);
      };
      Deque2.prototype.forEach = function(t2) {
        for (var i = 0; i < this.M; ++i) {
          t2(this.getElementByPos(i), i, this);
        }
      };
      Deque2.prototype[Symbol.iterator] = function() {
        return function() {
          var t2;
          return __generator3(this, function(i) {
            switch (i.label) {
              case 0:
                t2 = 0;
                i.label = 1;
              case 1:
                if (!(t2 < this.M))
                  return [3, 4];
                return [4, this.getElementByPos(t2)];
              case 2:
                i.sent();
                i.label = 3;
              case 3:
                ++t2;
                return [3, 1];
              case 4:
                return [2];
            }
          });
        }.bind(this)();
      };
      return Deque2;
    }(Base_default);
    Deque_default = Deque;
  }
});

// node_modules/js-sdsl/dist/esm/container/TreeContainer/Base/TreeNode.js
var __extends10, TreeNode, TreeNodeEnableIndex;
var init_TreeNode = __esm({
  "node_modules/js-sdsl/dist/esm/container/TreeContainer/Base/TreeNode.js"() {
    init_shim();
    __extends10 = function() {
      var extendStatics = function(e, n) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(e2, n2) {
          e2.__proto__ = n2;
        } || function(e2, n2) {
          for (var t in n2)
            if (Object.prototype.hasOwnProperty.call(n2, t))
              e2[t] = n2[t];
        };
        return extendStatics(e, n);
      };
      return function(e, n) {
        if (typeof n !== "function" && n !== null)
          throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
        extendStatics(e, n);
        function __() {
          this.constructor = e;
        }
        e.prototype = n === null ? Object.create(n) : (__.prototype = n.prototype, new __());
      };
    }();
    TreeNode = function() {
      function TreeNode2(e, n) {
        this.ee = 1;
        this.u = void 0;
        this.p = void 0;
        this.K = void 0;
        this.N = void 0;
        this.rr = void 0;
        this.u = e;
        this.p = n;
      }
      TreeNode2.prototype.L = function() {
        var e = this;
        if (e.ee === 1 && e.rr.rr === e) {
          e = e.N;
        } else if (e.K) {
          e = e.K;
          while (e.N) {
            e = e.N;
          }
        } else {
          var n = e.rr;
          while (n.K === e) {
            e = n;
            n = e.rr;
          }
          e = n;
        }
        return e;
      };
      TreeNode2.prototype.m = function() {
        var e = this;
        if (e.N) {
          e = e.N;
          while (e.K) {
            e = e.K;
          }
          return e;
        } else {
          var n = e.rr;
          while (n.N === e) {
            e = n;
            n = e.rr;
          }
          if (e.N !== n) {
            return n;
          } else
            return e;
        }
      };
      TreeNode2.prototype.ne = function() {
        var e = this.rr;
        var n = this.N;
        var t = n.K;
        if (e.rr === this)
          e.rr = n;
        else if (e.K === this)
          e.K = n;
        else
          e.N = n;
        n.rr = e;
        n.K = this;
        this.rr = n;
        this.N = t;
        if (t)
          t.rr = this;
        return n;
      };
      TreeNode2.prototype.te = function() {
        var e = this.rr;
        var n = this.K;
        var t = n.N;
        if (e.rr === this)
          e.rr = n;
        else if (e.K === this)
          e.K = n;
        else
          e.N = n;
        n.rr = e;
        n.N = this;
        this.rr = n;
        this.K = t;
        if (t)
          t.rr = this;
        return n;
      };
      return TreeNode2;
    }();
    TreeNodeEnableIndex = function(e) {
      __extends10(TreeNodeEnableIndex2, e);
      function TreeNodeEnableIndex2() {
        var n = e !== null && e.apply(this, arguments) || this;
        n.tr = 1;
        return n;
      }
      TreeNodeEnableIndex2.prototype.ne = function() {
        var n = e.prototype.ne.call(this);
        this.ie();
        n.ie();
        return n;
      };
      TreeNodeEnableIndex2.prototype.te = function() {
        var n = e.prototype.te.call(this);
        this.ie();
        n.ie();
        return n;
      };
      TreeNodeEnableIndex2.prototype.ie = function() {
        this.tr = 1;
        if (this.K) {
          this.tr += this.K.tr;
        }
        if (this.N) {
          this.tr += this.N.tr;
        }
      };
      return TreeNodeEnableIndex2;
    }(TreeNode);
  }
});

// node_modules/js-sdsl/dist/esm/container/TreeContainer/Base/index.js
var __extends11, __read4, __values2, TreeContainer, Base_default2;
var init_Base2 = __esm({
  "node_modules/js-sdsl/dist/esm/container/TreeContainer/Base/index.js"() {
    init_shim();
    init_TreeNode();
    init_ContainerBase();
    init_throwError();
    __extends11 = function() {
      var extendStatics = function(e, r) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(e2, r2) {
          e2.__proto__ = r2;
        } || function(e2, r2) {
          for (var i in r2)
            if (Object.prototype.hasOwnProperty.call(r2, i))
              e2[i] = r2[i];
        };
        return extendStatics(e, r);
      };
      return function(e, r) {
        if (typeof r !== "function" && r !== null)
          throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
        extendStatics(e, r);
        function __() {
          this.constructor = e;
        }
        e.prototype = r === null ? Object.create(r) : (__.prototype = r.prototype, new __());
      };
    }();
    __read4 = function(e, r) {
      var i = typeof Symbol === "function" && e[Symbol.iterator];
      if (!i)
        return e;
      var t = i.call(e), n, s = [], f;
      try {
        while ((r === void 0 || r-- > 0) && !(n = t.next()).done)
          s.push(n.value);
      } catch (e2) {
        f = {
          error: e2
        };
      } finally {
        try {
          if (n && !n.done && (i = t["return"]))
            i.call(t);
        } finally {
          if (f)
            throw f.error;
        }
      }
      return s;
    };
    __values2 = function(e) {
      var r = typeof Symbol === "function" && Symbol.iterator, i = r && e[r], t = 0;
      if (i)
        return i.call(e);
      if (e && typeof e.length === "number")
        return {
          next: function() {
            if (e && t >= e.length)
              e = void 0;
            return {
              value: e && e[t++],
              done: !e
            };
          }
        };
      throw new TypeError(r ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    TreeContainer = function(e) {
      __extends11(TreeContainer2, e);
      function TreeContainer2(r, i) {
        if (r === void 0) {
          r = function(e2, r2) {
            if (e2 < r2)
              return -1;
            if (e2 > r2)
              return 1;
            return 0;
          };
        }
        if (i === void 0) {
          i = false;
        }
        var t = e.call(this) || this;
        t.W = void 0;
        t.$ = r;
        if (i) {
          t.re = TreeNodeEnableIndex;
          t.v = function(e2, r2, i2) {
            var t2 = this.se(e2, r2, i2);
            if (t2) {
              var n = t2.rr;
              while (n !== this.h) {
                n.tr += 1;
                n = n.rr;
              }
              var s = this.fe(t2);
              if (s) {
                var f = s, h = f.parentNode, u = f.grandParent, a = f.curNode;
                h.ie();
                u.ie();
                a.ie();
              }
            }
            return this.M;
          };
          t.G = function(e2) {
            var r2 = this.he(e2);
            while (r2 !== this.h) {
              r2.tr -= 1;
              r2 = r2.rr;
            }
          };
        } else {
          t.re = TreeNode;
          t.v = function(e2, r2, i2) {
            var t2 = this.se(e2, r2, i2);
            if (t2)
              this.fe(t2);
            return this.M;
          };
          t.G = t.he;
        }
        t.h = new t.re();
        return t;
      }
      TreeContainer2.prototype.U = function(e2, r) {
        var i = this.h;
        while (e2) {
          var t = this.$(e2.u, r);
          if (t < 0) {
            e2 = e2.N;
          } else if (t > 0) {
            i = e2;
            e2 = e2.K;
          } else
            return e2;
        }
        return i;
      };
      TreeContainer2.prototype.X = function(e2, r) {
        var i = this.h;
        while (e2) {
          var t = this.$(e2.u, r);
          if (t <= 0) {
            e2 = e2.N;
          } else {
            i = e2;
            e2 = e2.K;
          }
        }
        return i;
      };
      TreeContainer2.prototype.Y = function(e2, r) {
        var i = this.h;
        while (e2) {
          var t = this.$(e2.u, r);
          if (t < 0) {
            i = e2;
            e2 = e2.N;
          } else if (t > 0) {
            e2 = e2.K;
          } else
            return e2;
        }
        return i;
      };
      TreeContainer2.prototype.Z = function(e2, r) {
        var i = this.h;
        while (e2) {
          var t = this.$(e2.u, r);
          if (t < 0) {
            i = e2;
            e2 = e2.N;
          } else {
            e2 = e2.K;
          }
        }
        return i;
      };
      TreeContainer2.prototype.ue = function(e2) {
        while (true) {
          var r = e2.rr;
          if (r === this.h)
            return;
          if (e2.ee === 1) {
            e2.ee = 0;
            return;
          }
          if (e2 === r.K) {
            var i = r.N;
            if (i.ee === 1) {
              i.ee = 0;
              r.ee = 1;
              if (r === this.W) {
                this.W = r.ne();
              } else
                r.ne();
            } else {
              if (i.N && i.N.ee === 1) {
                i.ee = r.ee;
                r.ee = 0;
                i.N.ee = 0;
                if (r === this.W) {
                  this.W = r.ne();
                } else
                  r.ne();
                return;
              } else if (i.K && i.K.ee === 1) {
                i.ee = 1;
                i.K.ee = 0;
                i.te();
              } else {
                i.ee = 1;
                e2 = r;
              }
            }
          } else {
            var i = r.K;
            if (i.ee === 1) {
              i.ee = 0;
              r.ee = 1;
              if (r === this.W) {
                this.W = r.te();
              } else
                r.te();
            } else {
              if (i.K && i.K.ee === 1) {
                i.ee = r.ee;
                r.ee = 0;
                i.K.ee = 0;
                if (r === this.W) {
                  this.W = r.te();
                } else
                  r.te();
                return;
              } else if (i.N && i.N.ee === 1) {
                i.ee = 1;
                i.N.ee = 0;
                i.ne();
              } else {
                i.ee = 1;
                e2 = r;
              }
            }
          }
        }
      };
      TreeContainer2.prototype.he = function(e2) {
        var r, i;
        if (this.M === 1) {
          this.clear();
          return this.h;
        }
        var t = e2;
        while (t.K || t.N) {
          if (t.N) {
            t = t.N;
            while (t.K)
              t = t.K;
          } else {
            t = t.K;
          }
          r = __read4([t.u, e2.u], 2), e2.u = r[0], t.u = r[1];
          i = __read4([t.p, e2.p], 2), e2.p = i[0], t.p = i[1];
          e2 = t;
        }
        if (this.h.K === t) {
          this.h.K = t.rr;
        } else if (this.h.N === t) {
          this.h.N = t.rr;
        }
        this.ue(t);
        var n = t.rr;
        if (t === n.K) {
          n.K = void 0;
        } else
          n.N = void 0;
        this.M -= 1;
        this.W.ee = 0;
        return n;
      };
      TreeContainer2.prototype.ae = function(e2, r) {
        if (e2 === void 0)
          return false;
        var i = this.ae(e2.K, r);
        if (i)
          return true;
        if (r(e2))
          return true;
        return this.ae(e2.N, r);
      };
      TreeContainer2.prototype.fe = function(e2) {
        while (true) {
          var r = e2.rr;
          if (r.ee === 0)
            return;
          var i = r.rr;
          if (r === i.K) {
            var t = i.N;
            if (t && t.ee === 1) {
              t.ee = r.ee = 0;
              if (i === this.W)
                return;
              i.ee = 1;
              e2 = i;
              continue;
            } else if (e2 === r.N) {
              e2.ee = 0;
              if (e2.K)
                e2.K.rr = r;
              if (e2.N)
                e2.N.rr = i;
              r.N = e2.K;
              i.K = e2.N;
              e2.K = r;
              e2.N = i;
              if (i === this.W) {
                this.W = e2;
                this.h.rr = e2;
              } else {
                var n = i.rr;
                if (n.K === i) {
                  n.K = e2;
                } else
                  n.N = e2;
              }
              e2.rr = i.rr;
              r.rr = e2;
              i.rr = e2;
              i.ee = 1;
              return {
                parentNode: r,
                grandParent: i,
                curNode: e2
              };
            } else {
              r.ee = 0;
              if (i === this.W) {
                this.W = i.te();
              } else
                i.te();
              i.ee = 1;
            }
          } else {
            var t = i.K;
            if (t && t.ee === 1) {
              t.ee = r.ee = 0;
              if (i === this.W)
                return;
              i.ee = 1;
              e2 = i;
              continue;
            } else if (e2 === r.K) {
              e2.ee = 0;
              if (e2.K)
                e2.K.rr = i;
              if (e2.N)
                e2.N.rr = r;
              i.N = e2.K;
              r.K = e2.N;
              e2.K = i;
              e2.N = r;
              if (i === this.W) {
                this.W = e2;
                this.h.rr = e2;
              } else {
                var n = i.rr;
                if (n.K === i) {
                  n.K = e2;
                } else
                  n.N = e2;
              }
              e2.rr = i.rr;
              r.rr = e2;
              i.rr = e2;
              i.ee = 1;
              return {
                parentNode: r,
                grandParent: i,
                curNode: e2
              };
            } else {
              r.ee = 0;
              if (i === this.W) {
                this.W = i.ne();
              } else
                i.ne();
              i.ee = 1;
            }
          }
          return;
        }
      };
      TreeContainer2.prototype.se = function(e2, r, i) {
        if (this.W === void 0) {
          this.M += 1;
          this.W = new this.re(e2, r);
          this.W.ee = 0;
          this.W.rr = this.h;
          this.h.rr = this.W;
          this.h.K = this.W;
          this.h.N = this.W;
          return;
        }
        var t;
        var n = this.h.K;
        var s = this.$(n.u, e2);
        if (s === 0) {
          n.p = r;
          return;
        } else if (s > 0) {
          n.K = new this.re(e2, r);
          n.K.rr = n;
          t = n.K;
          this.h.K = t;
        } else {
          var f = this.h.N;
          var h = this.$(f.u, e2);
          if (h === 0) {
            f.p = r;
            return;
          } else if (h < 0) {
            f.N = new this.re(e2, r);
            f.N.rr = f;
            t = f.N;
            this.h.N = t;
          } else {
            if (i !== void 0) {
              var u = i.o;
              if (u !== this.h) {
                var a = this.$(u.u, e2);
                if (a === 0) {
                  u.p = r;
                  return;
                } else if (a > 0) {
                  var o = u.L();
                  var l = this.$(o.u, e2);
                  if (l === 0) {
                    o.p = r;
                    return;
                  } else if (l < 0) {
                    t = new this.re(e2, r);
                    if (o.N === void 0) {
                      o.N = t;
                      t.rr = o;
                    } else {
                      u.K = t;
                      t.rr = u;
                    }
                  }
                }
              }
            }
            if (t === void 0) {
              t = this.W;
              while (true) {
                var v = this.$(t.u, e2);
                if (v > 0) {
                  if (t.K === void 0) {
                    t.K = new this.re(e2, r);
                    t.K.rr = t;
                    t = t.K;
                    break;
                  }
                  t = t.K;
                } else if (v < 0) {
                  if (t.N === void 0) {
                    t.N = new this.re(e2, r);
                    t.N.rr = t;
                    t = t.N;
                    break;
                  }
                  t = t.N;
                } else {
                  t.p = r;
                  return;
                }
              }
            }
          }
        }
        this.M += 1;
        return t;
      };
      TreeContainer2.prototype.g = function(e2, r) {
        while (e2) {
          var i = this.$(e2.u, r);
          if (i < 0) {
            e2 = e2.N;
          } else if (i > 0) {
            e2 = e2.K;
          } else
            return e2;
        }
        return e2 || this.h;
      };
      TreeContainer2.prototype.clear = function() {
        this.M = 0;
        this.W = void 0;
        this.h.rr = void 0;
        this.h.K = this.h.N = void 0;
      };
      TreeContainer2.prototype.updateKeyByIterator = function(e2, r) {
        var i = e2.o;
        if (i === this.h) {
          throwIteratorAccessError();
        }
        if (this.M === 1) {
          i.u = r;
          return true;
        }
        if (i === this.h.K) {
          if (this.$(i.m().u, r) > 0) {
            i.u = r;
            return true;
          }
          return false;
        }
        if (i === this.h.N) {
          if (this.$(i.L().u, r) < 0) {
            i.u = r;
            return true;
          }
          return false;
        }
        var t = i.L().u;
        if (this.$(t, r) >= 0)
          return false;
        var n = i.m().u;
        if (this.$(n, r) <= 0)
          return false;
        i.u = r;
        return true;
      };
      TreeContainer2.prototype.eraseElementByPos = function(e2) {
        if (e2 < 0 || e2 > this.M - 1) {
          throw new RangeError();
        }
        var r = 0;
        var i = this;
        this.ae(this.W, function(t) {
          if (e2 === r) {
            i.G(t);
            return true;
          }
          r += 1;
          return false;
        });
        return this.M;
      };
      TreeContainer2.prototype.eraseElementByKey = function(e2) {
        if (this.M === 0)
          return false;
        var r = this.g(this.W, e2);
        if (r === this.h)
          return false;
        this.G(r);
        return true;
      };
      TreeContainer2.prototype.eraseElementByIterator = function(e2) {
        var r = e2.o;
        if (r === this.h) {
          throwIteratorAccessError();
        }
        var i = r.N === void 0;
        var t = e2.iteratorType === 0;
        if (t) {
          if (i)
            e2.next();
        } else {
          if (!i || r.K === void 0)
            e2.next();
        }
        this.G(r);
        return e2;
      };
      TreeContainer2.prototype.forEach = function(e2) {
        var r, i;
        var t = 0;
        try {
          for (var n = __values2(this), s = n.next(); !s.done; s = n.next()) {
            var f = s.value;
            e2(f, t++, this);
          }
        } catch (e3) {
          r = {
            error: e3
          };
        } finally {
          try {
            if (s && !s.done && (i = n.return))
              i.call(n);
          } finally {
            if (r)
              throw r.error;
          }
        }
      };
      TreeContainer2.prototype.getElementByPos = function(e2) {
        var r, i;
        if (e2 < 0 || e2 > this.M - 1) {
          throw new RangeError();
        }
        var t;
        var n = 0;
        try {
          for (var s = __values2(this), f = s.next(); !f.done; f = s.next()) {
            var h = f.value;
            if (n === e2) {
              t = h;
              break;
            }
            n += 1;
          }
        } catch (e3) {
          r = {
            error: e3
          };
        } finally {
          try {
            if (f && !f.done && (i = s.return))
              i.call(s);
          } finally {
            if (r)
              throw r.error;
          }
        }
        return t;
      };
      TreeContainer2.prototype.getHeight = function() {
        if (this.M === 0)
          return 0;
        var traversal = function(e2) {
          if (!e2)
            return 0;
          return Math.max(traversal(e2.K), traversal(e2.N)) + 1;
        };
        return traversal(this.W);
      };
      return TreeContainer2;
    }(Container);
    Base_default2 = TreeContainer;
  }
});

// node_modules/js-sdsl/dist/esm/container/TreeContainer/Base/TreeIterator.js
var __extends12, TreeIterator, TreeIterator_default;
var init_TreeIterator = __esm({
  "node_modules/js-sdsl/dist/esm/container/TreeContainer/Base/TreeIterator.js"() {
    init_shim();
    init_ContainerBase();
    init_throwError();
    __extends12 = function() {
      var extendStatics = function(r, t) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(r2, t2) {
          r2.__proto__ = t2;
        } || function(r2, t2) {
          for (var e in t2)
            if (Object.prototype.hasOwnProperty.call(t2, e))
              r2[e] = t2[e];
        };
        return extendStatics(r, t);
      };
      return function(r, t) {
        if (typeof t !== "function" && t !== null)
          throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
        extendStatics(r, t);
        function __() {
          this.constructor = r;
        }
        r.prototype = t === null ? Object.create(t) : (__.prototype = t.prototype, new __());
      };
    }();
    TreeIterator = function(r) {
      __extends12(TreeIterator2, r);
      function TreeIterator2(t, e, i) {
        var n = r.call(this, i) || this;
        n.o = t;
        n.h = e;
        if (n.iteratorType === 0) {
          n.pre = function() {
            if (this.o === this.h.K) {
              throwIteratorAccessError();
            }
            this.o = this.o.L();
            return this;
          };
          n.next = function() {
            if (this.o === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.m();
            return this;
          };
        } else {
          n.pre = function() {
            if (this.o === this.h.N) {
              throwIteratorAccessError();
            }
            this.o = this.o.m();
            return this;
          };
          n.next = function() {
            if (this.o === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.L();
            return this;
          };
        }
        return n;
      }
      Object.defineProperty(TreeIterator2.prototype, "index", {
        get: function() {
          var r2 = this.o;
          var t = this.h.rr;
          if (r2 === this.h) {
            if (t) {
              return t.tr - 1;
            }
            return 0;
          }
          var e = 0;
          if (r2.K) {
            e += r2.K.tr;
          }
          while (r2 !== t) {
            var i = r2.rr;
            if (r2 === i.N) {
              e += 1;
              if (i.K) {
                e += i.K.tr;
              }
            }
            r2 = i;
          }
          return e;
        },
        enumerable: false,
        configurable: true
      });
      return TreeIterator2;
    }(ContainerIterator);
    TreeIterator_default = TreeIterator;
  }
});

// node_modules/js-sdsl/dist/esm/container/TreeContainer/OrderedSet.js
var __extends13, __generator4, __values3, OrderedSetIterator, OrderedSet, OrderedSet_default;
var init_OrderedSet = __esm({
  "node_modules/js-sdsl/dist/esm/container/TreeContainer/OrderedSet.js"() {
    init_shim();
    init_Base2();
    init_TreeIterator();
    init_throwError();
    __extends13 = function() {
      var extendStatics = function(e, t) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(e2, t2) {
          e2.__proto__ = t2;
        } || function(e2, t2) {
          for (var r in t2)
            if (Object.prototype.hasOwnProperty.call(t2, r))
              e2[r] = t2[r];
        };
        return extendStatics(e, t);
      };
      return function(e, t) {
        if (typeof t !== "function" && t !== null)
          throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
        extendStatics(e, t);
        function __() {
          this.constructor = e;
        }
        e.prototype = t === null ? Object.create(t) : (__.prototype = t.prototype, new __());
      };
    }();
    __generator4 = function(e, t) {
      var r = {
        label: 0,
        sent: function() {
          if (o[0] & 1)
            throw o[1];
          return o[1];
        },
        trys: [],
        ops: []
      }, n, i, o, u;
      return u = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol === "function" && (u[Symbol.iterator] = function() {
        return this;
      }), u;
      function verb(e2) {
        return function(t2) {
          return step([e2, t2]);
        };
      }
      function step(u2) {
        if (n)
          throw new TypeError("Generator is already executing.");
        while (r)
          try {
            if (n = 1, i && (o = u2[0] & 2 ? i["return"] : u2[0] ? i["throw"] || ((o = i["return"]) && o.call(i), 0) : i.next) && !(o = o.call(i, u2[1])).done)
              return o;
            if (i = 0, o)
              u2 = [u2[0] & 2, o.value];
            switch (u2[0]) {
              case 0:
              case 1:
                o = u2;
                break;
              case 4:
                r.label++;
                return {
                  value: u2[1],
                  done: false
                };
              case 5:
                r.label++;
                i = u2[1];
                u2 = [0];
                continue;
              case 7:
                u2 = r.ops.pop();
                r.trys.pop();
                continue;
              default:
                if (!(o = r.trys, o = o.length > 0 && o[o.length - 1]) && (u2[0] === 6 || u2[0] === 2)) {
                  r = 0;
                  continue;
                }
                if (u2[0] === 3 && (!o || u2[1] > o[0] && u2[1] < o[3])) {
                  r.label = u2[1];
                  break;
                }
                if (u2[0] === 6 && r.label < o[1]) {
                  r.label = o[1];
                  o = u2;
                  break;
                }
                if (o && r.label < o[2]) {
                  r.label = o[2];
                  r.ops.push(u2);
                  break;
                }
                if (o[2])
                  r.ops.pop();
                r.trys.pop();
                continue;
            }
            u2 = t.call(e, r);
          } catch (e2) {
            u2 = [6, e2];
            i = 0;
          } finally {
            n = o = 0;
          }
        if (u2[0] & 5)
          throw u2[1];
        return {
          value: u2[0] ? u2[1] : void 0,
          done: true
        };
      }
    };
    __values3 = function(e) {
      var t = typeof Symbol === "function" && Symbol.iterator, r = t && e[t], n = 0;
      if (r)
        return r.call(e);
      if (e && typeof e.length === "number")
        return {
          next: function() {
            if (e && n >= e.length)
              e = void 0;
            return {
              value: e && e[n++],
              done: !e
            };
          }
        };
      throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    OrderedSetIterator = function(e) {
      __extends13(OrderedSetIterator2, e);
      function OrderedSetIterator2(t, r, n, i) {
        var o = e.call(this, t, r, i) || this;
        o.container = n;
        return o;
      }
      Object.defineProperty(OrderedSetIterator2.prototype, "pointer", {
        get: function() {
          if (this.o === this.h) {
            throwIteratorAccessError();
          }
          return this.o.u;
        },
        enumerable: false,
        configurable: true
      });
      OrderedSetIterator2.prototype.copy = function() {
        return new OrderedSetIterator2(this.o, this.h, this.container, this.iteratorType);
      };
      return OrderedSetIterator2;
    }(TreeIterator_default);
    OrderedSet = function(e) {
      __extends13(OrderedSet2, e);
      function OrderedSet2(t, r, n) {
        if (t === void 0) {
          t = [];
        }
        var i = e.call(this, r, n) || this;
        var o = i;
        t.forEach(function(e2) {
          o.insert(e2);
        });
        return i;
      }
      OrderedSet2.prototype.P = function(e2) {
        return __generator4(this, function(t) {
          switch (t.label) {
            case 0:
              if (e2 === void 0)
                return [2];
              return [5, __values3(this.P(e2.K))];
            case 1:
              t.sent();
              return [4, e2.u];
            case 2:
              t.sent();
              return [5, __values3(this.P(e2.N))];
            case 3:
              t.sent();
              return [2];
          }
        });
      };
      OrderedSet2.prototype.begin = function() {
        return new OrderedSetIterator(this.h.K || this.h, this.h, this);
      };
      OrderedSet2.prototype.end = function() {
        return new OrderedSetIterator(this.h, this.h, this);
      };
      OrderedSet2.prototype.rBegin = function() {
        return new OrderedSetIterator(this.h.N || this.h, this.h, this, 1);
      };
      OrderedSet2.prototype.rEnd = function() {
        return new OrderedSetIterator(this.h, this.h, this, 1);
      };
      OrderedSet2.prototype.front = function() {
        return this.h.K ? this.h.K.u : void 0;
      };
      OrderedSet2.prototype.back = function() {
        return this.h.N ? this.h.N.u : void 0;
      };
      OrderedSet2.prototype.insert = function(e2, t) {
        return this.v(e2, void 0, t);
      };
      OrderedSet2.prototype.find = function(e2) {
        var t = this.g(this.W, e2);
        return new OrderedSetIterator(t, this.h, this);
      };
      OrderedSet2.prototype.lowerBound = function(e2) {
        var t = this.U(this.W, e2);
        return new OrderedSetIterator(t, this.h, this);
      };
      OrderedSet2.prototype.upperBound = function(e2) {
        var t = this.X(this.W, e2);
        return new OrderedSetIterator(t, this.h, this);
      };
      OrderedSet2.prototype.reverseLowerBound = function(e2) {
        var t = this.Y(this.W, e2);
        return new OrderedSetIterator(t, this.h, this);
      };
      OrderedSet2.prototype.reverseUpperBound = function(e2) {
        var t = this.Z(this.W, e2);
        return new OrderedSetIterator(t, this.h, this);
      };
      OrderedSet2.prototype.union = function(e2) {
        var t = this;
        e2.forEach(function(e3) {
          t.insert(e3);
        });
        return this.M;
      };
      OrderedSet2.prototype[Symbol.iterator] = function() {
        return this.P(this.W);
      };
      return OrderedSet2;
    }(Base_default2);
    OrderedSet_default = OrderedSet;
  }
});

// node_modules/js-sdsl/dist/esm/container/TreeContainer/OrderedMap.js
var __extends14, __generator5, __values4, OrderedMapIterator, OrderedMap, OrderedMap_default;
var init_OrderedMap = __esm({
  "node_modules/js-sdsl/dist/esm/container/TreeContainer/OrderedMap.js"() {
    init_shim();
    init_Base2();
    init_TreeIterator();
    init_throwError();
    __extends14 = function() {
      var extendStatics = function(r, e) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(r2, e2) {
          r2.__proto__ = e2;
        } || function(r2, e2) {
          for (var t in e2)
            if (Object.prototype.hasOwnProperty.call(e2, t))
              r2[t] = e2[t];
        };
        return extendStatics(r, e);
      };
      return function(r, e) {
        if (typeof e !== "function" && e !== null)
          throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
        extendStatics(r, e);
        function __() {
          this.constructor = r;
        }
        r.prototype = e === null ? Object.create(e) : (__.prototype = e.prototype, new __());
      };
    }();
    __generator5 = function(r, e) {
      var t = {
        label: 0,
        sent: function() {
          if (o[0] & 1)
            throw o[1];
          return o[1];
        },
        trys: [],
        ops: []
      }, n, i, o, a;
      return a = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol === "function" && (a[Symbol.iterator] = function() {
        return this;
      }), a;
      function verb(r2) {
        return function(e2) {
          return step([r2, e2]);
        };
      }
      function step(a2) {
        if (n)
          throw new TypeError("Generator is already executing.");
        while (t)
          try {
            if (n = 1, i && (o = a2[0] & 2 ? i["return"] : a2[0] ? i["throw"] || ((o = i["return"]) && o.call(i), 0) : i.next) && !(o = o.call(i, a2[1])).done)
              return o;
            if (i = 0, o)
              a2 = [a2[0] & 2, o.value];
            switch (a2[0]) {
              case 0:
              case 1:
                o = a2;
                break;
              case 4:
                t.label++;
                return {
                  value: a2[1],
                  done: false
                };
              case 5:
                t.label++;
                i = a2[1];
                a2 = [0];
                continue;
              case 7:
                a2 = t.ops.pop();
                t.trys.pop();
                continue;
              default:
                if (!(o = t.trys, o = o.length > 0 && o[o.length - 1]) && (a2[0] === 6 || a2[0] === 2)) {
                  t = 0;
                  continue;
                }
                if (a2[0] === 3 && (!o || a2[1] > o[0] && a2[1] < o[3])) {
                  t.label = a2[1];
                  break;
                }
                if (a2[0] === 6 && t.label < o[1]) {
                  t.label = o[1];
                  o = a2;
                  break;
                }
                if (o && t.label < o[2]) {
                  t.label = o[2];
                  t.ops.push(a2);
                  break;
                }
                if (o[2])
                  t.ops.pop();
                t.trys.pop();
                continue;
            }
            a2 = e.call(r, t);
          } catch (r2) {
            a2 = [6, r2];
            i = 0;
          } finally {
            n = o = 0;
          }
        if (a2[0] & 5)
          throw a2[1];
        return {
          value: a2[0] ? a2[1] : void 0,
          done: true
        };
      }
    };
    __values4 = function(r) {
      var e = typeof Symbol === "function" && Symbol.iterator, t = e && r[e], n = 0;
      if (t)
        return t.call(r);
      if (r && typeof r.length === "number")
        return {
          next: function() {
            if (r && n >= r.length)
              r = void 0;
            return {
              value: r && r[n++],
              done: !r
            };
          }
        };
      throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    OrderedMapIterator = function(r) {
      __extends14(OrderedMapIterator2, r);
      function OrderedMapIterator2(e, t, n, i) {
        var o = r.call(this, e, t, i) || this;
        o.container = n;
        return o;
      }
      Object.defineProperty(OrderedMapIterator2.prototype, "pointer", {
        get: function() {
          if (this.o === this.h) {
            throwIteratorAccessError();
          }
          var r2 = this;
          return new Proxy([], {
            get: function(e, t) {
              if (t === "0")
                return r2.o.u;
              else if (t === "1")
                return r2.o.p;
            },
            set: function(e, t, n) {
              if (t !== "1") {
                throw new TypeError("props must be 1");
              }
              r2.o.p = n;
              return true;
            }
          });
        },
        enumerable: false,
        configurable: true
      });
      OrderedMapIterator2.prototype.copy = function() {
        return new OrderedMapIterator2(this.o, this.h, this.container, this.iteratorType);
      };
      return OrderedMapIterator2;
    }(TreeIterator_default);
    OrderedMap = function(r) {
      __extends14(OrderedMap2, r);
      function OrderedMap2(e, t, n) {
        if (e === void 0) {
          e = [];
        }
        var i = r.call(this, t, n) || this;
        var o = i;
        e.forEach(function(r2) {
          o.setElement(r2[0], r2[1]);
        });
        return i;
      }
      OrderedMap2.prototype.P = function(r2) {
        return __generator5(this, function(e) {
          switch (e.label) {
            case 0:
              if (r2 === void 0)
                return [2];
              return [5, __values4(this.P(r2.K))];
            case 1:
              e.sent();
              return [4, [r2.u, r2.p]];
            case 2:
              e.sent();
              return [5, __values4(this.P(r2.N))];
            case 3:
              e.sent();
              return [2];
          }
        });
      };
      OrderedMap2.prototype.begin = function() {
        return new OrderedMapIterator(this.h.K || this.h, this.h, this);
      };
      OrderedMap2.prototype.end = function() {
        return new OrderedMapIterator(this.h, this.h, this);
      };
      OrderedMap2.prototype.rBegin = function() {
        return new OrderedMapIterator(this.h.N || this.h, this.h, this, 1);
      };
      OrderedMap2.prototype.rEnd = function() {
        return new OrderedMapIterator(this.h, this.h, this, 1);
      };
      OrderedMap2.prototype.front = function() {
        if (this.M === 0)
          return;
        var r2 = this.h.K;
        return [r2.u, r2.p];
      };
      OrderedMap2.prototype.back = function() {
        if (this.M === 0)
          return;
        var r2 = this.h.N;
        return [r2.u, r2.p];
      };
      OrderedMap2.prototype.lowerBound = function(r2) {
        var e = this.U(this.W, r2);
        return new OrderedMapIterator(e, this.h, this);
      };
      OrderedMap2.prototype.upperBound = function(r2) {
        var e = this.X(this.W, r2);
        return new OrderedMapIterator(e, this.h, this);
      };
      OrderedMap2.prototype.reverseLowerBound = function(r2) {
        var e = this.Y(this.W, r2);
        return new OrderedMapIterator(e, this.h, this);
      };
      OrderedMap2.prototype.reverseUpperBound = function(r2) {
        var e = this.Z(this.W, r2);
        return new OrderedMapIterator(e, this.h, this);
      };
      OrderedMap2.prototype.setElement = function(r2, e, t) {
        return this.v(r2, e, t);
      };
      OrderedMap2.prototype.find = function(r2) {
        var e = this.g(this.W, r2);
        return new OrderedMapIterator(e, this.h, this);
      };
      OrderedMap2.prototype.getElementByKey = function(r2) {
        var e = this.g(this.W, r2);
        return e.p;
      };
      OrderedMap2.prototype.union = function(r2) {
        var e = this;
        r2.forEach(function(r3) {
          e.setElement(r3[0], r3[1]);
        });
        return this.M;
      };
      OrderedMap2.prototype[Symbol.iterator] = function() {
        return this.P(this.W);
      };
      return OrderedMap2;
    }(Base_default2);
    OrderedMap_default = OrderedMap;
  }
});

// node_modules/js-sdsl/dist/esm/utils/checkObject.js
function checkObject(t) {
  var e = typeof t;
  return e === "object" && t !== null || e === "function";
}
var init_checkObject = __esm({
  "node_modules/js-sdsl/dist/esm/utils/checkObject.js"() {
    init_shim();
  }
});

// node_modules/js-sdsl/dist/esm/container/HashContainer/Base/index.js
var __extends15, HashContainerIterator, HashContainer;
var init_Base3 = __esm({
  "node_modules/js-sdsl/dist/esm/container/HashContainer/Base/index.js"() {
    init_shim();
    init_ContainerBase();
    init_checkObject();
    init_throwError();
    __extends15 = function() {
      var extendStatics = function(t, i) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(t2, i2) {
          t2.__proto__ = i2;
        } || function(t2, i2) {
          for (var r in i2)
            if (Object.prototype.hasOwnProperty.call(i2, r))
              t2[r] = i2[r];
        };
        return extendStatics(t, i);
      };
      return function(t, i) {
        if (typeof i !== "function" && i !== null)
          throw new TypeError("Class extends value " + String(i) + " is not a constructor or null");
        extendStatics(t, i);
        function __() {
          this.constructor = t;
        }
        t.prototype = i === null ? Object.create(i) : (__.prototype = i.prototype, new __());
      };
    }();
    HashContainerIterator = function(t) {
      __extends15(HashContainerIterator2, t);
      function HashContainerIterator2(i, r, e) {
        var n = t.call(this, e) || this;
        n.o = i;
        n.h = r;
        if (n.iteratorType === 0) {
          n.pre = function() {
            if (this.o.L === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.L;
            return this;
          };
          n.next = function() {
            if (this.o === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.m;
            return this;
          };
        } else {
          n.pre = function() {
            if (this.o.m === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.m;
            return this;
          };
          n.next = function() {
            if (this.o === this.h) {
              throwIteratorAccessError();
            }
            this.o = this.o.L;
            return this;
          };
        }
        return n;
      }
      return HashContainerIterator2;
    }(ContainerIterator);
    HashContainer = function(t) {
      __extends15(HashContainer2, t);
      function HashContainer2() {
        var i = t.call(this) || this;
        i._ = [];
        i.I = {};
        i.HASH_TAG = Symbol("@@HASH_TAG");
        Object.setPrototypeOf(i.I, null);
        i.h = {};
        i.h.L = i.h.m = i.H = i.l = i.h;
        return i;
      }
      HashContainer2.prototype.G = function(t2) {
        var i = t2.L, r = t2.m;
        i.m = r;
        r.L = i;
        if (t2 === this.H) {
          this.H = r;
        }
        if (t2 === this.l) {
          this.l = i;
        }
        this.M -= 1;
      };
      HashContainer2.prototype.v = function(t2, i, r) {
        if (r === void 0)
          r = checkObject(t2);
        var e;
        if (r) {
          var n = t2[this.HASH_TAG];
          if (n !== void 0) {
            this._[n].p = i;
            return this.M;
          }
          Object.defineProperty(t2, this.HASH_TAG, {
            value: this._.length,
            configurable: true
          });
          e = {
            u: t2,
            p: i,
            L: this.l,
            m: this.h
          };
          this._.push(e);
        } else {
          var s = this.I[t2];
          if (s) {
            s.p = i;
            return this.M;
          }
          e = {
            u: t2,
            p: i,
            L: this.l,
            m: this.h
          };
          this.I[t2] = e;
        }
        if (this.M === 0) {
          this.H = e;
          this.h.m = e;
        } else {
          this.l.m = e;
        }
        this.l = e;
        this.h.L = e;
        return ++this.M;
      };
      HashContainer2.prototype.g = function(t2, i) {
        if (i === void 0)
          i = checkObject(t2);
        if (i) {
          var r = t2[this.HASH_TAG];
          if (r === void 0)
            return this.h;
          return this._[r];
        } else {
          return this.I[t2] || this.h;
        }
      };
      HashContainer2.prototype.clear = function() {
        var t2 = this.HASH_TAG;
        this._.forEach(function(i) {
          delete i.u[t2];
        });
        this._ = [];
        this.I = {};
        Object.setPrototypeOf(this.I, null);
        this.M = 0;
        this.H = this.l = this.h.L = this.h.m = this.h;
      };
      HashContainer2.prototype.eraseElementByKey = function(t2, i) {
        var r;
        if (i === void 0)
          i = checkObject(t2);
        if (i) {
          var e = t2[this.HASH_TAG];
          if (e === void 0)
            return false;
          delete t2[this.HASH_TAG];
          r = this._[e];
          delete this._[e];
        } else {
          r = this.I[t2];
          if (r === void 0)
            return false;
          delete this.I[t2];
        }
        this.G(r);
        return true;
      };
      HashContainer2.prototype.eraseElementByIterator = function(t2) {
        var i = t2.o;
        if (i === this.h) {
          throwIteratorAccessError();
        }
        this.G(i);
        return t2.next();
      };
      HashContainer2.prototype.eraseElementByPos = function(t2) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        var i = this.H;
        while (t2--) {
          i = i.m;
        }
        this.G(i);
        return this.M;
      };
      return HashContainer2;
    }(Container);
  }
});

// node_modules/js-sdsl/dist/esm/container/HashContainer/HashSet.js
var __extends16, __generator6, HashSetIterator, HashSet, HashSet_default;
var init_HashSet = __esm({
  "node_modules/js-sdsl/dist/esm/container/HashContainer/HashSet.js"() {
    init_shim();
    init_Base3();
    init_throwError();
    __extends16 = function() {
      var extendStatics = function(t, r) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(t2, r2) {
          t2.__proto__ = r2;
        } || function(t2, r2) {
          for (var e in r2)
            if (Object.prototype.hasOwnProperty.call(r2, e))
              t2[e] = r2[e];
        };
        return extendStatics(t, r);
      };
      return function(t, r) {
        if (typeof r !== "function" && r !== null)
          throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
        extendStatics(t, r);
        function __() {
          this.constructor = t;
        }
        t.prototype = r === null ? Object.create(r) : (__.prototype = r.prototype, new __());
      };
    }();
    __generator6 = function(t, r) {
      var e = {
        label: 0,
        sent: function() {
          if (s[0] & 1)
            throw s[1];
          return s[1];
        },
        trys: [],
        ops: []
      }, n, i, s, a;
      return a = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol === "function" && (a[Symbol.iterator] = function() {
        return this;
      }), a;
      function verb(t2) {
        return function(r2) {
          return step([t2, r2]);
        };
      }
      function step(a2) {
        if (n)
          throw new TypeError("Generator is already executing.");
        while (e)
          try {
            if (n = 1, i && (s = a2[0] & 2 ? i["return"] : a2[0] ? i["throw"] || ((s = i["return"]) && s.call(i), 0) : i.next) && !(s = s.call(i, a2[1])).done)
              return s;
            if (i = 0, s)
              a2 = [a2[0] & 2, s.value];
            switch (a2[0]) {
              case 0:
              case 1:
                s = a2;
                break;
              case 4:
                e.label++;
                return {
                  value: a2[1],
                  done: false
                };
              case 5:
                e.label++;
                i = a2[1];
                a2 = [0];
                continue;
              case 7:
                a2 = e.ops.pop();
                e.trys.pop();
                continue;
              default:
                if (!(s = e.trys, s = s.length > 0 && s[s.length - 1]) && (a2[0] === 6 || a2[0] === 2)) {
                  e = 0;
                  continue;
                }
                if (a2[0] === 3 && (!s || a2[1] > s[0] && a2[1] < s[3])) {
                  e.label = a2[1];
                  break;
                }
                if (a2[0] === 6 && e.label < s[1]) {
                  e.label = s[1];
                  s = a2;
                  break;
                }
                if (s && e.label < s[2]) {
                  e.label = s[2];
                  e.ops.push(a2);
                  break;
                }
                if (s[2])
                  e.ops.pop();
                e.trys.pop();
                continue;
            }
            a2 = r.call(t, e);
          } catch (t2) {
            a2 = [6, t2];
            i = 0;
          } finally {
            n = s = 0;
          }
        if (a2[0] & 5)
          throw a2[1];
        return {
          value: a2[0] ? a2[1] : void 0,
          done: true
        };
      }
    };
    HashSetIterator = function(t) {
      __extends16(HashSetIterator2, t);
      function HashSetIterator2(r, e, n, i) {
        var s = t.call(this, r, e, i) || this;
        s.container = n;
        return s;
      }
      Object.defineProperty(HashSetIterator2.prototype, "pointer", {
        get: function() {
          if (this.o === this.h) {
            throwIteratorAccessError();
          }
          return this.o.u;
        },
        enumerable: false,
        configurable: true
      });
      HashSetIterator2.prototype.copy = function() {
        return new HashSetIterator2(this.o, this.h, this.container, this.iteratorType);
      };
      return HashSetIterator2;
    }(HashContainerIterator);
    HashSet = function(t) {
      __extends16(HashSet2, t);
      function HashSet2(r) {
        if (r === void 0) {
          r = [];
        }
        var e = t.call(this) || this;
        var n = e;
        r.forEach(function(t2) {
          n.insert(t2);
        });
        return e;
      }
      HashSet2.prototype.begin = function() {
        return new HashSetIterator(this.H, this.h, this);
      };
      HashSet2.prototype.end = function() {
        return new HashSetIterator(this.h, this.h, this);
      };
      HashSet2.prototype.rBegin = function() {
        return new HashSetIterator(this.l, this.h, this, 1);
      };
      HashSet2.prototype.rEnd = function() {
        return new HashSetIterator(this.h, this.h, this, 1);
      };
      HashSet2.prototype.front = function() {
        return this.H.u;
      };
      HashSet2.prototype.back = function() {
        return this.l.u;
      };
      HashSet2.prototype.insert = function(t2, r) {
        return this.v(t2, void 0, r);
      };
      HashSet2.prototype.getElementByPos = function(t2) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        var r = this.H;
        while (t2--) {
          r = r.m;
        }
        return r.u;
      };
      HashSet2.prototype.find = function(t2, r) {
        var e = this.g(t2, r);
        return new HashSetIterator(e, this.h, this);
      };
      HashSet2.prototype.forEach = function(t2) {
        var r = 0;
        var e = this.H;
        while (e !== this.h) {
          t2(e.u, r++, this);
          e = e.m;
        }
      };
      HashSet2.prototype[Symbol.iterator] = function() {
        return function() {
          var t2;
          return __generator6(this, function(r) {
            switch (r.label) {
              case 0:
                t2 = this.H;
                r.label = 1;
              case 1:
                if (!(t2 !== this.h))
                  return [3, 3];
                return [4, t2.u];
              case 2:
                r.sent();
                t2 = t2.m;
                return [3, 1];
              case 3:
                return [2];
            }
          });
        }.bind(this)();
      };
      return HashSet2;
    }(HashContainer);
    HashSet_default = HashSet;
  }
});

// node_modules/js-sdsl/dist/esm/container/HashContainer/HashMap.js
var __extends17, __generator7, HashMapIterator, HashMap, HashMap_default;
var init_HashMap = __esm({
  "node_modules/js-sdsl/dist/esm/container/HashContainer/HashMap.js"() {
    init_shim();
    init_Base3();
    init_checkObject();
    init_throwError();
    __extends17 = function() {
      var extendStatics = function(t, r) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(t2, r2) {
          t2.__proto__ = r2;
        } || function(t2, r2) {
          for (var n in r2)
            if (Object.prototype.hasOwnProperty.call(r2, n))
              t2[n] = r2[n];
        };
        return extendStatics(t, r);
      };
      return function(t, r) {
        if (typeof r !== "function" && r !== null)
          throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
        extendStatics(t, r);
        function __() {
          this.constructor = t;
        }
        t.prototype = r === null ? Object.create(r) : (__.prototype = r.prototype, new __());
      };
    }();
    __generator7 = function(t, r) {
      var n = {
        label: 0,
        sent: function() {
          if (a[0] & 1)
            throw a[1];
          return a[1];
        },
        trys: [],
        ops: []
      }, e, i, a, s;
      return s = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, typeof Symbol === "function" && (s[Symbol.iterator] = function() {
        return this;
      }), s;
      function verb(t2) {
        return function(r2) {
          return step([t2, r2]);
        };
      }
      function step(s2) {
        if (e)
          throw new TypeError("Generator is already executing.");
        while (n)
          try {
            if (e = 1, i && (a = s2[0] & 2 ? i["return"] : s2[0] ? i["throw"] || ((a = i["return"]) && a.call(i), 0) : i.next) && !(a = a.call(i, s2[1])).done)
              return a;
            if (i = 0, a)
              s2 = [s2[0] & 2, a.value];
            switch (s2[0]) {
              case 0:
              case 1:
                a = s2;
                break;
              case 4:
                n.label++;
                return {
                  value: s2[1],
                  done: false
                };
              case 5:
                n.label++;
                i = s2[1];
                s2 = [0];
                continue;
              case 7:
                s2 = n.ops.pop();
                n.trys.pop();
                continue;
              default:
                if (!(a = n.trys, a = a.length > 0 && a[a.length - 1]) && (s2[0] === 6 || s2[0] === 2)) {
                  n = 0;
                  continue;
                }
                if (s2[0] === 3 && (!a || s2[1] > a[0] && s2[1] < a[3])) {
                  n.label = s2[1];
                  break;
                }
                if (s2[0] === 6 && n.label < a[1]) {
                  n.label = a[1];
                  a = s2;
                  break;
                }
                if (a && n.label < a[2]) {
                  n.label = a[2];
                  n.ops.push(s2);
                  break;
                }
                if (a[2])
                  n.ops.pop();
                n.trys.pop();
                continue;
            }
            s2 = r.call(t, n);
          } catch (t2) {
            s2 = [6, t2];
            i = 0;
          } finally {
            e = a = 0;
          }
        if (s2[0] & 5)
          throw s2[1];
        return {
          value: s2[0] ? s2[1] : void 0,
          done: true
        };
      }
    };
    HashMapIterator = function(t) {
      __extends17(HashMapIterator2, t);
      function HashMapIterator2(r, n, e, i) {
        var a = t.call(this, r, n, i) || this;
        a.container = e;
        return a;
      }
      Object.defineProperty(HashMapIterator2.prototype, "pointer", {
        get: function() {
          if (this.o === this.h) {
            throwIteratorAccessError();
          }
          var t2 = this;
          return new Proxy([], {
            get: function(r, n) {
              if (n === "0")
                return t2.o.u;
              else if (n === "1")
                return t2.o.p;
            },
            set: function(r, n, e) {
              if (n !== "1") {
                throw new TypeError("props must be 1");
              }
              t2.o.p = e;
              return true;
            }
          });
        },
        enumerable: false,
        configurable: true
      });
      HashMapIterator2.prototype.copy = function() {
        return new HashMapIterator2(this.o, this.h, this.container, this.iteratorType);
      };
      return HashMapIterator2;
    }(HashContainerIterator);
    HashMap = function(t) {
      __extends17(HashMap2, t);
      function HashMap2(r) {
        if (r === void 0) {
          r = [];
        }
        var n = t.call(this) || this;
        var e = n;
        r.forEach(function(t2) {
          e.setElement(t2[0], t2[1]);
        });
        return n;
      }
      HashMap2.prototype.begin = function() {
        return new HashMapIterator(this.H, this.h, this);
      };
      HashMap2.prototype.end = function() {
        return new HashMapIterator(this.h, this.h, this);
      };
      HashMap2.prototype.rBegin = function() {
        return new HashMapIterator(this.l, this.h, this, 1);
      };
      HashMap2.prototype.rEnd = function() {
        return new HashMapIterator(this.h, this.h, this, 1);
      };
      HashMap2.prototype.front = function() {
        if (this.M === 0)
          return;
        return [this.H.u, this.H.p];
      };
      HashMap2.prototype.back = function() {
        if (this.M === 0)
          return;
        return [this.l.u, this.l.p];
      };
      HashMap2.prototype.setElement = function(t2, r, n) {
        return this.v(t2, r, n);
      };
      HashMap2.prototype.getElementByKey = function(t2, r) {
        if (r === void 0)
          r = checkObject(t2);
        if (r) {
          var n = t2[this.HASH_TAG];
          return n !== void 0 ? this._[n].p : void 0;
        }
        var e = this.I[t2];
        return e ? e.p : void 0;
      };
      HashMap2.prototype.getElementByPos = function(t2) {
        if (t2 < 0 || t2 > this.M - 1) {
          throw new RangeError();
        }
        var r = this.H;
        while (t2--) {
          r = r.m;
        }
        return [r.u, r.p];
      };
      HashMap2.prototype.find = function(t2, r) {
        var n = this.g(t2, r);
        return new HashMapIterator(n, this.h, this);
      };
      HashMap2.prototype.forEach = function(t2) {
        var r = 0;
        var n = this.H;
        while (n !== this.h) {
          t2([n.u, n.p], r++, this);
          n = n.m;
        }
      };
      HashMap2.prototype[Symbol.iterator] = function() {
        return function() {
          var t2;
          return __generator7(this, function(r) {
            switch (r.label) {
              case 0:
                t2 = this.H;
                r.label = 1;
              case 1:
                if (!(t2 !== this.h))
                  return [3, 3];
                return [4, [t2.u, t2.p]];
              case 2:
                r.sent();
                t2 = t2.m;
                return [3, 1];
              case 3:
                return [2];
            }
          });
        }.bind(this)();
      };
      return HashMap2;
    }(HashContainer);
    HashMap_default = HashMap;
  }
});

// node_modules/js-sdsl/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  Deque: () => Deque_default,
  HashMap: () => HashMap_default,
  HashSet: () => HashSet_default,
  LinkList: () => LinkList_default,
  OrderedMap: () => OrderedMap_default,
  OrderedSet: () => OrderedSet_default,
  PriorityQueue: () => PriorityQueue_default,
  Queue: () => Queue_default,
  Stack: () => Stack_default,
  Vector: () => Vector_default
});
var init_esm = __esm({
  "node_modules/js-sdsl/dist/esm/index.js"() {
    init_shim();
    init_Stack();
    init_Queue();
    init_PriorityQueue();
    init_Vector();
    init_LinkList();
    init_Deque();
    init_OrderedSet();
    init_OrderedMap();
    init_HashSet();
    init_HashMap();
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    init_shim();
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse4(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse4(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    init_shim();
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format2];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    init_shim();
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof import_process.default !== "undefined" && "env" in import_process.default) {
        r = import_process.default.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/number-allocator/lib/number-allocator.js
var require_number_allocator = __commonJS({
  "node_modules/number-allocator/lib/number-allocator.js"(exports, module) {
    "use strict";
    init_shim();
    var SortedSet = (init_esm(), __toCommonJS(esm_exports)).OrderedSet;
    var debugTrace = require_browser2()("number-allocator:trace");
    var debugError = require_browser2()("number-allocator:error");
    function Interval(low, high) {
      this.low = low;
      this.high = high;
    }
    Interval.prototype.equals = function(other) {
      return this.low === other.low && this.high === other.high;
    };
    Interval.prototype.compare = function(other) {
      if (this.low < other.low && this.high < other.low)
        return -1;
      if (other.low < this.low && other.high < this.low)
        return 1;
      return 0;
    };
    function NumberAllocator(min, max) {
      if (!(this instanceof NumberAllocator)) {
        return new NumberAllocator(min, max);
      }
      this.min = min;
      this.max = max;
      this.ss = new SortedSet(
        [],
        (lhs, rhs) => {
          return lhs.compare(rhs);
        }
      );
      debugTrace("Create");
      this.clear();
    }
    NumberAllocator.prototype.firstVacant = function() {
      if (this.ss.size() === 0)
        return null;
      return this.ss.front().low;
    };
    NumberAllocator.prototype.alloc = function() {
      if (this.ss.size() === 0) {
        debugTrace("alloc():empty");
        return null;
      }
      const it = this.ss.begin();
      const low = it.pointer.low;
      const high = it.pointer.high;
      const num = low;
      if (num + 1 <= high) {
        this.ss.updateKeyByIterator(it, new Interval(low + 1, high));
      } else {
        this.ss.eraseElementByPos(0);
      }
      debugTrace("alloc():" + num);
      return num;
    };
    NumberAllocator.prototype.use = function(num) {
      const key = new Interval(num, num);
      const it = this.ss.lowerBound(key);
      if (!it.equals(this.ss.end())) {
        const low = it.pointer.low;
        const high = it.pointer.high;
        if (it.pointer.equals(key)) {
          this.ss.eraseElementByIterator(it);
          debugTrace("use():" + num);
          return true;
        }
        if (low > num)
          return false;
        if (low === num) {
          this.ss.updateKeyByIterator(it, new Interval(low + 1, high));
          debugTrace("use():" + num);
          return true;
        }
        if (high === num) {
          this.ss.updateKeyByIterator(it, new Interval(low, high - 1));
          debugTrace("use():" + num);
          return true;
        }
        this.ss.updateKeyByIterator(it, new Interval(num + 1, high));
        this.ss.insert(new Interval(low, num - 1));
        debugTrace("use():" + num);
        return true;
      }
      debugTrace("use():failed");
      return false;
    };
    NumberAllocator.prototype.free = function(num) {
      if (num < this.min || num > this.max) {
        debugError("free():" + num + " is out of range");
        return;
      }
      const key = new Interval(num, num);
      const it = this.ss.upperBound(key);
      if (it.equals(this.ss.end())) {
        if (it.equals(this.ss.begin())) {
          this.ss.insert(key);
          return;
        }
        it.pre();
        const low = it.pointer.high;
        const high = it.pointer.high;
        if (high + 1 === num) {
          this.ss.updateKeyByIterator(it, new Interval(low, num));
        } else {
          this.ss.insert(key);
        }
      } else {
        if (it.equals(this.ss.begin())) {
          if (num + 1 === it.pointer.low) {
            const high = it.pointer.high;
            this.ss.updateKeyByIterator(it, new Interval(num, high));
          } else {
            this.ss.insert(key);
          }
        } else {
          const rLow = it.pointer.low;
          const rHigh = it.pointer.high;
          it.pre();
          const lLow = it.pointer.low;
          const lHigh = it.pointer.high;
          if (lHigh + 1 === num) {
            if (num + 1 === rLow) {
              this.ss.eraseElementByIterator(it);
              this.ss.updateKeyByIterator(it, new Interval(lLow, rHigh));
            } else {
              this.ss.updateKeyByIterator(it, new Interval(lLow, num));
            }
          } else {
            if (num + 1 === rLow) {
              this.ss.eraseElementByIterator(it.next());
              this.ss.insert(new Interval(num, rHigh));
            } else {
              this.ss.insert(key);
            }
          }
        }
      }
      debugTrace("free():" + num);
    };
    NumberAllocator.prototype.clear = function() {
      debugTrace("clear()");
      this.ss.clear();
      this.ss.insert(new Interval(this.min, this.max));
    };
    NumberAllocator.prototype.intervalCount = function() {
      return this.ss.size();
    };
    NumberAllocator.prototype.dump = function() {
      console.log("length:" + this.ss.size());
      for (const element of this.ss) {
        console.log(element);
      }
    };
    module.exports = NumberAllocator;
  }
});

// node_modules/number-allocator/index.js
var require_number_allocator2 = __commonJS({
  "node_modules/number-allocator/index.js"(exports, module) {
    init_shim();
    var NumberAllocator = require_number_allocator();
    module.exports.NumberAllocator = NumberAllocator;
  }
});

// node_modules/mqtt/lib/topic-alias-send.js
var require_topic_alias_send = __commonJS({
  "node_modules/mqtt/lib/topic-alias-send.js"(exports, module) {
    "use strict";
    init_shim();
    var LruMap = require_lru_cache();
    var NumberAllocator = require_number_allocator2().NumberAllocator;
    function TopicAliasSend(max) {
      if (!(this instanceof TopicAliasSend)) {
        return new TopicAliasSend(max);
      }
      if (max > 0) {
        this.aliasToTopic = new LruMap({ max });
        this.topicToAlias = {};
        this.numberAllocator = new NumberAllocator(1, max);
        this.max = max;
        this.length = 0;
      }
    }
    TopicAliasSend.prototype.put = function(topic, alias) {
      if (alias === 0 || alias > this.max) {
        return false;
      }
      const entry = this.aliasToTopic.get(alias);
      if (entry) {
        delete this.topicToAlias[entry];
      }
      this.aliasToTopic.set(alias, topic);
      this.topicToAlias[topic] = alias;
      this.numberAllocator.use(alias);
      this.length = this.aliasToTopic.length;
      return true;
    };
    TopicAliasSend.prototype.getTopicByAlias = function(alias) {
      return this.aliasToTopic.get(alias);
    };
    TopicAliasSend.prototype.getAliasByTopic = function(topic) {
      const alias = this.topicToAlias[topic];
      if (typeof alias !== "undefined") {
        this.aliasToTopic.get(alias);
      }
      return alias;
    };
    TopicAliasSend.prototype.clear = function() {
      this.aliasToTopic.reset();
      this.topicToAlias = {};
      this.numberAllocator.clear();
      this.length = 0;
    };
    TopicAliasSend.prototype.getLruAlias = function() {
      const alias = this.numberAllocator.firstVacant();
      if (alias)
        return alias;
      return this.aliasToTopic.keys()[this.aliasToTopic.length - 1];
    };
    module.exports = TopicAliasSend;
  }
});

// node_modules/bl/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/bl/BufferList.js"(exports, module) {
    "use strict";
    init_shim();
    var { Buffer: Buffer2 } = require_buffer();
    var symbol = Symbol.for("BufferList");
    function BufferList(buf) {
      if (!(this instanceof BufferList)) {
        return new BufferList(buf);
      }
      BufferList._init.call(this, buf);
    }
    BufferList._init = function _init(buf) {
      Object.defineProperty(this, symbol, { value: true });
      this._bufs = [];
      this.length = 0;
      if (buf) {
        this.append(buf);
      }
    };
    BufferList.prototype._new = function _new(buf) {
      return new BufferList(buf);
    };
    BufferList.prototype._offset = function _offset(offset) {
      if (offset === 0) {
        return [0, 0];
      }
      let tot = 0;
      for (let i = 0; i < this._bufs.length; i++) {
        const _t = tot + this._bufs[i].length;
        if (offset < _t || i === this._bufs.length - 1) {
          return [i, offset - tot];
        }
        tot = _t;
      }
    };
    BufferList.prototype._reverseOffset = function(blOffset) {
      const bufferId = blOffset[0];
      let offset = blOffset[1];
      for (let i = 0; i < bufferId; i++) {
        offset += this._bufs[i].length;
      }
      return offset;
    };
    BufferList.prototype.get = function get(index) {
      if (index > this.length || index < 0) {
        return void 0;
      }
      const offset = this._offset(index);
      return this._bufs[offset[0]][offset[1]];
    };
    BufferList.prototype.slice = function slice(start, end) {
      if (typeof start === "number" && start < 0) {
        start += this.length;
      }
      if (typeof end === "number" && end < 0) {
        end += this.length;
      }
      return this.copy(null, 0, start, end);
    };
    BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart !== "number" || srcStart < 0) {
        srcStart = 0;
      }
      if (typeof srcEnd !== "number" || srcEnd > this.length) {
        srcEnd = this.length;
      }
      if (srcStart >= this.length) {
        return dst || Buffer2.alloc(0);
      }
      if (srcEnd <= 0) {
        return dst || Buffer2.alloc(0);
      }
      const copy2 = !!dst;
      const off = this._offset(srcStart);
      const len = srcEnd - srcStart;
      let bytes = len;
      let bufoff = copy2 && dstStart || 0;
      let start = off[1];
      if (srcStart === 0 && srcEnd === this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
        }
        for (let i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }
        return dst;
      }
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
      }
      if (!copy2) {
        dst = Buffer2.allocUnsafe(len);
      }
      for (let i = off[0]; i < this._bufs.length; i++) {
        const l = this._bufs[i].length - start;
        if (bytes > l) {
          this._bufs[i].copy(dst, bufoff, start);
          bufoff += l;
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes);
          bufoff += l;
          break;
        }
        bytes -= l;
        if (start) {
          start = 0;
        }
      }
      if (dst.length > bufoff)
        return dst.slice(0, bufoff);
      return dst;
    };
    BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = typeof end !== "number" ? this.length : end;
      if (start < 0) {
        start += this.length;
      }
      if (end < 0) {
        end += this.length;
      }
      if (start === end) {
        return this._new();
      }
      const startOffset = this._offset(start);
      const endOffset = this._offset(end);
      const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] === 0) {
        buffers.pop();
      } else {
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      }
      if (startOffset[1] !== 0) {
        buffers[0] = buffers[0].slice(startOffset[1]);
      }
      return this._new(buffers);
    };
    BufferList.prototype.toString = function toString(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList.prototype.consume = function consume(bytes) {
      bytes = Math.trunc(bytes);
      if (Number.isNaN(bytes) || bytes <= 0)
        return this;
      while (this._bufs.length) {
        if (bytes >= this._bufs[0].length) {
          bytes -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes);
          this.length -= bytes;
          break;
        }
      }
      return this;
    };
    BufferList.prototype.duplicate = function duplicate() {
      const copy = this._new();
      for (let i = 0; i < this._bufs.length; i++) {
        copy.append(this._bufs[i]);
      }
      return copy;
    };
    BufferList.prototype.append = function append(buf) {
      if (buf == null) {
        return this;
      }
      if (buf.buffer) {
        this._appendBuffer(Buffer2.from(buf.buffer, buf.byteOffset, buf.byteLength));
      } else if (Array.isArray(buf)) {
        for (let i = 0; i < buf.length; i++) {
          this.append(buf[i]);
        }
      } else if (this._isBufferList(buf)) {
        for (let i = 0; i < buf._bufs.length; i++) {
          this.append(buf._bufs[i]);
        }
      } else {
        if (typeof buf === "number") {
          buf = buf.toString();
        }
        this._appendBuffer(Buffer2.from(buf));
      }
      return this;
    };
    BufferList.prototype._appendBuffer = function appendBuffer(buf) {
      this._bufs.push(buf);
      this.length += buf.length;
    };
    BufferList.prototype.indexOf = function(search, offset, encoding) {
      if (encoding === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      }
      if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
      } else if (typeof search === "number") {
        search = Buffer2.from([search]);
      } else if (typeof search === "string") {
        search = Buffer2.from(search, encoding);
      } else if (this._isBufferList(search)) {
        search = search.slice();
      } else if (Array.isArray(search.buffer)) {
        search = Buffer2.from(search.buffer, search.byteOffset, search.byteLength);
      } else if (!Buffer2.isBuffer(search)) {
        search = Buffer2.from(search);
      }
      offset = Number(offset || 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      const blOffset = this._offset(offset);
      let blIndex = blOffset[0];
      let buffOffset = blOffset[1];
      for (; blIndex < this._bufs.length; blIndex++) {
        const buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          const availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            const nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            const revOffset = this._reverseOffset([blIndex, buffOffset]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList.prototype._match = function(offset, search) {
      if (this.length - offset < search.length) {
        return false;
      }
      for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function() {
      const methods = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null
      };
      for (const m in methods) {
        (function(m2) {
          if (methods[m2] === null) {
            BufferList.prototype[m2] = function(offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m2](0, byteLength);
            };
          } else {
            BufferList.prototype[m2] = function(offset = 0) {
              return this.slice(offset, offset + methods[m2])[m2](0);
            };
          }
        })(m);
      }
    })();
    BufferList.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferList || BufferList.isBufferList(b);
    };
    BufferList.isBufferList = function isBufferList(b) {
      return b != null && b[symbol];
    };
    module.exports = BufferList;
  }
});

// node_modules/bl/bl.js
var require_bl = __commonJS({
  "node_modules/bl/bl.js"(exports, module) {
    "use strict";
    init_shim();
    var DuplexStream = require_readable_browser().Duplex;
    var inherits = require_inherits_browser();
    var BufferList = require_BufferList();
    function BufferListStream(callback) {
      if (!(this instanceof BufferListStream)) {
        return new BufferListStream(callback);
      }
      if (typeof callback === "function") {
        this._callback = callback;
        const piper = function piper2(err) {
          if (this._callback) {
            this._callback(err);
            this._callback = null;
          }
        }.bind(this);
        this.on("pipe", function onPipe(src) {
          src.on("error", piper);
        });
        this.on("unpipe", function onUnpipe(src) {
          src.removeListener("error", piper);
        });
        callback = null;
      }
      BufferList._init.call(this, callback);
      DuplexStream.call(this);
    }
    inherits(BufferListStream, DuplexStream);
    Object.assign(BufferListStream.prototype, BufferList.prototype);
    BufferListStream.prototype._new = function _new(callback) {
      return new BufferListStream(callback);
    };
    BufferListStream.prototype._write = function _write(buf, encoding, callback) {
      this._appendBuffer(buf);
      if (typeof callback === "function") {
        callback();
      }
    };
    BufferListStream.prototype._read = function _read(size) {
      if (!this.length) {
        return this.push(null);
      }
      size = Math.min(size, this.length);
      this.push(this.slice(0, size));
      this.consume(size);
    };
    BufferListStream.prototype.end = function end(chunk) {
      DuplexStream.prototype.end.call(this, chunk);
      if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
      }
    };
    BufferListStream.prototype._destroy = function _destroy(err, cb) {
      this._bufs.length = 0;
      this.length = 0;
      cb(err);
    };
    BufferListStream.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b);
    };
    BufferListStream.isBufferList = BufferList.isBufferList;
    module.exports = BufferListStream;
    module.exports.BufferListStream = BufferListStream;
    module.exports.BufferList = BufferList;
  }
});

// node_modules/mqtt-packet/packet.js
var require_packet = __commonJS({
  "node_modules/mqtt-packet/packet.js"(exports, module) {
    init_shim();
    var Packet = class {
      constructor() {
        this.cmd = null;
        this.retain = false;
        this.qos = 0;
        this.dup = false;
        this.length = -1;
        this.topic = null;
        this.payload = null;
      }
    };
    module.exports = Packet;
  }
});

// node_modules/mqtt-packet/constants.js
var require_constants = __commonJS({
  "node_modules/mqtt-packet/constants.js"(exports, module) {
    init_shim();
    var protocol = module.exports;
    protocol.types = {
      0: "reserved",
      1: "connect",
      2: "connack",
      3: "publish",
      4: "puback",
      5: "pubrec",
      6: "pubrel",
      7: "pubcomp",
      8: "subscribe",
      9: "suback",
      10: "unsubscribe",
      11: "unsuback",
      12: "pingreq",
      13: "pingresp",
      14: "disconnect",
      15: "auth"
    };
    protocol.codes = {};
    for (const k in protocol.types) {
      const v = protocol.types[k];
      protocol.codes[v] = k;
    }
    protocol.CMD_SHIFT = 4;
    protocol.CMD_MASK = 240;
    protocol.DUP_MASK = 8;
    protocol.QOS_MASK = 3;
    protocol.QOS_SHIFT = 1;
    protocol.RETAIN_MASK = 1;
    protocol.VARBYTEINT_MASK = 127;
    protocol.VARBYTEINT_FIN_MASK = 128;
    protocol.VARBYTEINT_MAX = 268435455;
    protocol.SESSIONPRESENT_MASK = 1;
    protocol.SESSIONPRESENT_HEADER = import_buffer.Buffer.from([protocol.SESSIONPRESENT_MASK]);
    protocol.CONNACK_HEADER = import_buffer.Buffer.from([protocol.codes.connack << protocol.CMD_SHIFT]);
    protocol.USERNAME_MASK = 128;
    protocol.PASSWORD_MASK = 64;
    protocol.WILL_RETAIN_MASK = 32;
    protocol.WILL_QOS_MASK = 24;
    protocol.WILL_QOS_SHIFT = 3;
    protocol.WILL_FLAG_MASK = 4;
    protocol.CLEAN_SESSION_MASK = 2;
    protocol.CONNECT_HEADER = import_buffer.Buffer.from([protocol.codes.connect << protocol.CMD_SHIFT]);
    protocol.properties = {
      sessionExpiryInterval: 17,
      willDelayInterval: 24,
      receiveMaximum: 33,
      maximumPacketSize: 39,
      topicAliasMaximum: 34,
      requestResponseInformation: 25,
      requestProblemInformation: 23,
      userProperties: 38,
      authenticationMethod: 21,
      authenticationData: 22,
      payloadFormatIndicator: 1,
      messageExpiryInterval: 2,
      contentType: 3,
      responseTopic: 8,
      correlationData: 9,
      maximumQoS: 36,
      retainAvailable: 37,
      assignedClientIdentifier: 18,
      reasonString: 31,
      wildcardSubscriptionAvailable: 40,
      subscriptionIdentifiersAvailable: 41,
      sharedSubscriptionAvailable: 42,
      serverKeepAlive: 19,
      responseInformation: 26,
      serverReference: 28,
      topicAlias: 35,
      subscriptionIdentifier: 11
    };
    protocol.propertiesCodes = {};
    for (const prop in protocol.properties) {
      const id = protocol.properties[prop];
      protocol.propertiesCodes[id] = prop;
    }
    protocol.propertiesTypes = {
      sessionExpiryInterval: "int32",
      willDelayInterval: "int32",
      receiveMaximum: "int16",
      maximumPacketSize: "int32",
      topicAliasMaximum: "int16",
      requestResponseInformation: "byte",
      requestProblemInformation: "byte",
      userProperties: "pair",
      authenticationMethod: "string",
      authenticationData: "binary",
      payloadFormatIndicator: "byte",
      messageExpiryInterval: "int32",
      contentType: "string",
      responseTopic: "string",
      correlationData: "binary",
      maximumQoS: "int8",
      retainAvailable: "byte",
      assignedClientIdentifier: "string",
      reasonString: "string",
      wildcardSubscriptionAvailable: "byte",
      subscriptionIdentifiersAvailable: "byte",
      sharedSubscriptionAvailable: "byte",
      serverKeepAlive: "int16",
      responseInformation: "string",
      serverReference: "string",
      topicAlias: "int16",
      subscriptionIdentifier: "var"
    };
    function genHeader(type) {
      return [0, 1, 2].map((qos) => {
        return [0, 1].map((dup) => {
          return [0, 1].map((retain) => {
            const buf = import_buffer.Buffer.alloc(1);
            buf.writeUInt8(
              protocol.codes[type] << protocol.CMD_SHIFT | (dup ? protocol.DUP_MASK : 0) | qos << protocol.QOS_SHIFT | retain,
              0,
              true
            );
            return buf;
          });
        });
      });
    }
    protocol.PUBLISH_HEADER = genHeader("publish");
    protocol.SUBSCRIBE_HEADER = genHeader("subscribe");
    protocol.SUBSCRIBE_OPTIONS_QOS_MASK = 3;
    protocol.SUBSCRIBE_OPTIONS_NL_MASK = 1;
    protocol.SUBSCRIBE_OPTIONS_NL_SHIFT = 2;
    protocol.SUBSCRIBE_OPTIONS_RAP_MASK = 1;
    protocol.SUBSCRIBE_OPTIONS_RAP_SHIFT = 3;
    protocol.SUBSCRIBE_OPTIONS_RH_MASK = 3;
    protocol.SUBSCRIBE_OPTIONS_RH_SHIFT = 4;
    protocol.SUBSCRIBE_OPTIONS_RH = [0, 16, 32];
    protocol.SUBSCRIBE_OPTIONS_NL = 4;
    protocol.SUBSCRIBE_OPTIONS_RAP = 8;
    protocol.SUBSCRIBE_OPTIONS_QOS = [0, 1, 2];
    protocol.UNSUBSCRIBE_HEADER = genHeader("unsubscribe");
    protocol.ACKS = {
      unsuback: genHeader("unsuback"),
      puback: genHeader("puback"),
      pubcomp: genHeader("pubcomp"),
      pubrel: genHeader("pubrel"),
      pubrec: genHeader("pubrec")
    };
    protocol.SUBACK_HEADER = import_buffer.Buffer.from([protocol.codes.suback << protocol.CMD_SHIFT]);
    protocol.VERSION3 = import_buffer.Buffer.from([3]);
    protocol.VERSION4 = import_buffer.Buffer.from([4]);
    protocol.VERSION5 = import_buffer.Buffer.from([5]);
    protocol.VERSION131 = import_buffer.Buffer.from([131]);
    protocol.VERSION132 = import_buffer.Buffer.from([132]);
    protocol.QOS = [0, 1, 2].map((qos) => {
      return import_buffer.Buffer.from([qos]);
    });
    protocol.EMPTY = {
      pingreq: import_buffer.Buffer.from([protocol.codes.pingreq << 4, 0]),
      pingresp: import_buffer.Buffer.from([protocol.codes.pingresp << 4, 0]),
      disconnect: import_buffer.Buffer.from([protocol.codes.disconnect << 4, 0])
    };
  }
});

// node_modules/mqtt-packet/parser.js
var require_parser = __commonJS({
  "node_modules/mqtt-packet/parser.js"(exports, module) {
    init_shim();
    var bl = require_bl();
    var EventEmitter = require_events();
    var Packet = require_packet();
    var constants = require_constants();
    var debug = require_browser2()("mqtt-packet:parser");
    var Parser = class extends EventEmitter {
      constructor() {
        super();
        this.parser = this.constructor.parser;
      }
      static parser(opt) {
        if (!(this instanceof Parser))
          return new Parser().parser(opt);
        this.settings = opt || {};
        this._states = [
          "_parseHeader",
          "_parseLength",
          "_parsePayload",
          "_newPacket"
        ];
        this._resetState();
        return this;
      }
      _resetState() {
        debug("_resetState: resetting packet, error, _list, and _stateCounter");
        this.packet = new Packet();
        this.error = null;
        this._list = bl();
        this._stateCounter = 0;
      }
      parse(buf) {
        if (this.error)
          this._resetState();
        this._list.append(buf);
        debug("parse: current state: %s", this._states[this._stateCounter]);
        while ((this.packet.length !== -1 || this._list.length > 0) && this[this._states[this._stateCounter]]() && !this.error) {
          this._stateCounter++;
          debug("parse: state complete. _stateCounter is now: %d", this._stateCounter);
          debug("parse: packet.length: %d, buffer list length: %d", this.packet.length, this._list.length);
          if (this._stateCounter >= this._states.length)
            this._stateCounter = 0;
        }
        debug("parse: exited while loop. packet: %d, buffer list length: %d", this.packet.length, this._list.length);
        return this._list.length;
      }
      _parseHeader() {
        const zero = this._list.readUInt8(0);
        this.packet.cmd = constants.types[zero >> constants.CMD_SHIFT];
        this.packet.retain = (zero & constants.RETAIN_MASK) !== 0;
        this.packet.qos = zero >> constants.QOS_SHIFT & constants.QOS_MASK;
        this.packet.dup = (zero & constants.DUP_MASK) !== 0;
        debug("_parseHeader: packet: %o", this.packet);
        this._list.consume(1);
        return true;
      }
      _parseLength() {
        const result = this._parseVarByteNum(true);
        if (result) {
          this.packet.length = result.value;
          this._list.consume(result.bytes);
        }
        debug("_parseLength %d", result.value);
        return !!result;
      }
      _parsePayload() {
        debug("_parsePayload: payload %O", this._list);
        let result = false;
        if (this.packet.length === 0 || this._list.length >= this.packet.length) {
          this._pos = 0;
          switch (this.packet.cmd) {
            case "connect":
              this._parseConnect();
              break;
            case "connack":
              this._parseConnack();
              break;
            case "publish":
              this._parsePublish();
              break;
            case "puback":
            case "pubrec":
            case "pubrel":
            case "pubcomp":
              this._parseConfirmation();
              break;
            case "subscribe":
              this._parseSubscribe();
              break;
            case "suback":
              this._parseSuback();
              break;
            case "unsubscribe":
              this._parseUnsubscribe();
              break;
            case "unsuback":
              this._parseUnsuback();
              break;
            case "pingreq":
            case "pingresp":
              break;
            case "disconnect":
              this._parseDisconnect();
              break;
            case "auth":
              this._parseAuth();
              break;
            default:
              this._emitError(new Error("Not supported"));
          }
          result = true;
        }
        debug("_parsePayload complete result: %s", result);
        return result;
      }
      _parseConnect() {
        debug("_parseConnect");
        let topic;
        let payload;
        let password;
        let username;
        const flags = {};
        const packet = this.packet;
        const protocolId = this._parseString();
        if (protocolId === null)
          return this._emitError(new Error("Cannot parse protocolId"));
        if (protocolId !== "MQTT" && protocolId !== "MQIsdp") {
          return this._emitError(new Error("Invalid protocolId"));
        }
        packet.protocolId = protocolId;
        if (this._pos >= this._list.length)
          return this._emitError(new Error("Packet too short"));
        packet.protocolVersion = this._list.readUInt8(this._pos);
        if (packet.protocolVersion >= 128) {
          packet.bridgeMode = true;
          packet.protocolVersion = packet.protocolVersion - 128;
        }
        if (packet.protocolVersion !== 3 && packet.protocolVersion !== 4 && packet.protocolVersion !== 5) {
          return this._emitError(new Error("Invalid protocol version"));
        }
        this._pos++;
        if (this._pos >= this._list.length) {
          return this._emitError(new Error("Packet too short"));
        }
        flags.username = this._list.readUInt8(this._pos) & constants.USERNAME_MASK;
        flags.password = this._list.readUInt8(this._pos) & constants.PASSWORD_MASK;
        flags.will = this._list.readUInt8(this._pos) & constants.WILL_FLAG_MASK;
        if (flags.will) {
          packet.will = {};
          packet.will.retain = (this._list.readUInt8(this._pos) & constants.WILL_RETAIN_MASK) !== 0;
          packet.will.qos = (this._list.readUInt8(this._pos) & constants.WILL_QOS_MASK) >> constants.WILL_QOS_SHIFT;
        }
        packet.clean = (this._list.readUInt8(this._pos) & constants.CLEAN_SESSION_MASK) !== 0;
        this._pos++;
        packet.keepalive = this._parseNum();
        if (packet.keepalive === -1)
          return this._emitError(new Error("Packet too short"));
        if (packet.protocolVersion === 5) {
          const properties = this._parseProperties();
          if (Object.getOwnPropertyNames(properties).length) {
            packet.properties = properties;
          }
        }
        const clientId = this._parseString();
        if (clientId === null)
          return this._emitError(new Error("Packet too short"));
        packet.clientId = clientId;
        debug("_parseConnect: packet.clientId: %s", packet.clientId);
        if (flags.will) {
          if (packet.protocolVersion === 5) {
            const willProperties = this._parseProperties();
            if (Object.getOwnPropertyNames(willProperties).length) {
              packet.will.properties = willProperties;
            }
          }
          topic = this._parseString();
          if (topic === null)
            return this._emitError(new Error("Cannot parse will topic"));
          packet.will.topic = topic;
          debug("_parseConnect: packet.will.topic: %s", packet.will.topic);
          payload = this._parseBuffer();
          if (payload === null)
            return this._emitError(new Error("Cannot parse will payload"));
          packet.will.payload = payload;
          debug("_parseConnect: packet.will.paylaod: %s", packet.will.payload);
        }
        if (flags.username) {
          username = this._parseString();
          if (username === null)
            return this._emitError(new Error("Cannot parse username"));
          packet.username = username;
          debug("_parseConnect: packet.username: %s", packet.username);
        }
        if (flags.password) {
          password = this._parseBuffer();
          if (password === null)
            return this._emitError(new Error("Cannot parse password"));
          packet.password = password;
        }
        this.settings = packet;
        debug("_parseConnect: complete");
        return packet;
      }
      _parseConnack() {
        debug("_parseConnack");
        const packet = this.packet;
        if (this._list.length < 1)
          return null;
        packet.sessionPresent = !!(this._list.readUInt8(this._pos++) & constants.SESSIONPRESENT_MASK);
        if (this.settings.protocolVersion === 5) {
          if (this._list.length >= 2) {
            packet.reasonCode = this._list.readUInt8(this._pos++);
          } else {
            packet.reasonCode = 0;
          }
        } else {
          if (this._list.length < 2)
            return null;
          packet.returnCode = this._list.readUInt8(this._pos++);
        }
        if (packet.returnCode === -1 || packet.reasonCode === -1)
          return this._emitError(new Error("Cannot parse return code"));
        if (this.settings.protocolVersion === 5) {
          const properties = this._parseProperties();
          if (Object.getOwnPropertyNames(properties).length) {
            packet.properties = properties;
          }
        }
        debug("_parseConnack: complete");
      }
      _parsePublish() {
        debug("_parsePublish");
        const packet = this.packet;
        packet.topic = this._parseString();
        if (packet.topic === null)
          return this._emitError(new Error("Cannot parse topic"));
        if (packet.qos > 0) {
          if (!this._parseMessageId()) {
            return;
          }
        }
        if (this.settings.protocolVersion === 5) {
          const properties = this._parseProperties();
          if (Object.getOwnPropertyNames(properties).length) {
            packet.properties = properties;
          }
        }
        packet.payload = this._list.slice(this._pos, packet.length);
        debug("_parsePublish: payload from buffer list: %o", packet.payload);
      }
      _parseSubscribe() {
        debug("_parseSubscribe");
        const packet = this.packet;
        let topic;
        let options;
        let qos;
        let rh;
        let rap;
        let nl;
        let subscription;
        if (packet.qos !== 1) {
          return this._emitError(new Error("Wrong subscribe header"));
        }
        packet.subscriptions = [];
        if (!this._parseMessageId()) {
          return;
        }
        if (this.settings.protocolVersion === 5) {
          const properties = this._parseProperties();
          if (Object.getOwnPropertyNames(properties).length) {
            packet.properties = properties;
          }
        }
        while (this._pos < packet.length) {
          topic = this._parseString();
          if (topic === null)
            return this._emitError(new Error("Cannot parse topic"));
          if (this._pos >= packet.length)
            return this._emitError(new Error("Malformed Subscribe Payload"));
          options = this._parseByte();
          qos = options & constants.SUBSCRIBE_OPTIONS_QOS_MASK;
          nl = (options >> constants.SUBSCRIBE_OPTIONS_NL_SHIFT & constants.SUBSCRIBE_OPTIONS_NL_MASK) !== 0;
          rap = (options >> constants.SUBSCRIBE_OPTIONS_RAP_SHIFT & constants.SUBSCRIBE_OPTIONS_RAP_MASK) !== 0;
          rh = options >> constants.SUBSCRIBE_OPTIONS_RH_SHIFT & constants.SUBSCRIBE_OPTIONS_RH_MASK;
          subscription = { topic, qos };
          if (this.settings.protocolVersion === 5) {
            subscription.nl = nl;
            subscription.rap = rap;
            subscription.rh = rh;
          } else if (this.settings.bridgeMode) {
            subscription.rh = 0;
            subscription.rap = true;
            subscription.nl = true;
          }
          debug("_parseSubscribe: push subscription `%s` to subscription", subscription);
          packet.subscriptions.push(subscription);
        }
      }
      _parseSuback() {
        debug("_parseSuback");
        const packet = this.packet;
        this.packet.granted = [];
        if (!this._parseMessageId()) {
          return;
        }
        if (this.settings.protocolVersion === 5) {
          const properties = this._parseProperties();
          if (Object.getOwnPropertyNames(properties).length) {
            packet.properties = properties;
          }
        }
        while (this._pos < this.packet.length) {
          this.packet.granted.push(this._list.readUInt8(this._pos++));
        }
      }
      _parseUnsubscribe() {
        debug("_parseUnsubscribe");
        const packet = this.packet;
        packet.unsubscriptions = [];
        if (!this._parseMessageId()) {
          return;
        }
        if (this.settings.protocolVersion === 5) {
          const properties = this._parseProperties();
          if (Object.getOwnPropertyNames(properties).length) {
            packet.properties = properties;
          }
        }
        while (this._pos < packet.length) {
          const topic = this._parseString();
          if (topic === null)
            return this._emitError(new Error("Cannot parse topic"));
          debug("_parseUnsubscribe: push topic `%s` to unsubscriptions", topic);
          packet.unsubscriptions.push(topic);
        }
      }
      _parseUnsuback() {
        debug("_parseUnsuback");
        const packet = this.packet;
        if (!this._parseMessageId())
          return this._emitError(new Error("Cannot parse messageId"));
        if (this.settings.protocolVersion === 5) {
          const properties = this._parseProperties();
          if (Object.getOwnPropertyNames(properties).length) {
            packet.properties = properties;
          }
          packet.granted = [];
          while (this._pos < this.packet.length) {
            this.packet.granted.push(this._list.readUInt8(this._pos++));
          }
        }
      }
      // parse packets like puback, pubrec, pubrel, pubcomp
      _parseConfirmation() {
        debug("_parseConfirmation: packet.cmd: `%s`", this.packet.cmd);
        const packet = this.packet;
        this._parseMessageId();
        if (this.settings.protocolVersion === 5) {
          if (packet.length > 2) {
            packet.reasonCode = this._parseByte();
            debug("_parseConfirmation: packet.reasonCode `%d`", packet.reasonCode);
          } else {
            packet.reasonCode = 0;
          }
          if (packet.length > 3) {
            const properties = this._parseProperties();
            if (Object.getOwnPropertyNames(properties).length) {
              packet.properties = properties;
            }
          }
        }
        return true;
      }
      // parse disconnect packet
      _parseDisconnect() {
        const packet = this.packet;
        debug("_parseDisconnect");
        if (this.settings.protocolVersion === 5) {
          if (this._list.length > 0) {
            packet.reasonCode = this._parseByte();
          } else {
            packet.reasonCode = 0;
          }
          const properties = this._parseProperties();
          if (Object.getOwnPropertyNames(properties).length) {
            packet.properties = properties;
          }
        }
        debug("_parseDisconnect result: true");
        return true;
      }
      // parse auth packet
      _parseAuth() {
        debug("_parseAuth");
        const packet = this.packet;
        if (this.settings.protocolVersion !== 5) {
          return this._emitError(new Error("Not supported auth packet for this version MQTT"));
        }
        packet.reasonCode = this._parseByte();
        const properties = this._parseProperties();
        if (Object.getOwnPropertyNames(properties).length) {
          packet.properties = properties;
        }
        debug("_parseAuth: result: true");
        return true;
      }
      _parseMessageId() {
        const packet = this.packet;
        packet.messageId = this._parseNum();
        if (packet.messageId === null) {
          this._emitError(new Error("Cannot parse messageId"));
          return false;
        }
        debug("_parseMessageId: packet.messageId %d", packet.messageId);
        return true;
      }
      _parseString(maybeBuffer) {
        const length = this._parseNum();
        const end = length + this._pos;
        if (length === -1 || end > this._list.length || end > this.packet.length)
          return null;
        const result = this._list.toString("utf8", this._pos, end);
        this._pos += length;
        debug("_parseString: result: %s", result);
        return result;
      }
      _parseStringPair() {
        debug("_parseStringPair");
        return {
          name: this._parseString(),
          value: this._parseString()
        };
      }
      _parseBuffer() {
        const length = this._parseNum();
        const end = length + this._pos;
        if (length === -1 || end > this._list.length || end > this.packet.length)
          return null;
        const result = this._list.slice(this._pos, end);
        this._pos += length;
        debug("_parseBuffer: result: %o", result);
        return result;
      }
      _parseNum() {
        if (this._list.length - this._pos < 2)
          return -1;
        const result = this._list.readUInt16BE(this._pos);
        this._pos += 2;
        debug("_parseNum: result: %s", result);
        return result;
      }
      _parse4ByteNum() {
        if (this._list.length - this._pos < 4)
          return -1;
        const result = this._list.readUInt32BE(this._pos);
        this._pos += 4;
        debug("_parse4ByteNum: result: %s", result);
        return result;
      }
      _parseVarByteNum(fullInfoFlag) {
        debug("_parseVarByteNum");
        const maxBytes = 4;
        let bytes = 0;
        let mul = 1;
        let value = 0;
        let result = false;
        let current;
        const padding = this._pos ? this._pos : 0;
        while (bytes < maxBytes && padding + bytes < this._list.length) {
          current = this._list.readUInt8(padding + bytes++);
          value += mul * (current & constants.VARBYTEINT_MASK);
          mul *= 128;
          if ((current & constants.VARBYTEINT_FIN_MASK) === 0) {
            result = true;
            break;
          }
          if (this._list.length <= bytes) {
            break;
          }
        }
        if (!result && bytes === maxBytes && this._list.length >= bytes) {
          this._emitError(new Error("Invalid variable byte integer"));
        }
        if (padding) {
          this._pos += bytes;
        }
        result = result ? fullInfoFlag ? {
          bytes,
          value
        } : value : false;
        debug("_parseVarByteNum: result: %o", result);
        return result;
      }
      _parseByte() {
        let result;
        if (this._pos < this._list.length) {
          result = this._list.readUInt8(this._pos);
          this._pos++;
        }
        debug("_parseByte: result: %o", result);
        return result;
      }
      _parseByType(type) {
        debug("_parseByType: type: %s", type);
        switch (type) {
          case "byte": {
            return this._parseByte() !== 0;
          }
          case "int8": {
            return this._parseByte();
          }
          case "int16": {
            return this._parseNum();
          }
          case "int32": {
            return this._parse4ByteNum();
          }
          case "var": {
            return this._parseVarByteNum();
          }
          case "string": {
            return this._parseString();
          }
          case "pair": {
            return this._parseStringPair();
          }
          case "binary": {
            return this._parseBuffer();
          }
        }
      }
      _parseProperties() {
        debug("_parseProperties");
        const length = this._parseVarByteNum();
        const start = this._pos;
        const end = start + length;
        const result = {};
        while (this._pos < end) {
          const type = this._parseByte();
          if (!type) {
            this._emitError(new Error("Cannot parse property code type"));
            return false;
          }
          const name = constants.propertiesCodes[type];
          if (!name) {
            this._emitError(new Error("Unknown property"));
            return false;
          }
          if (name === "userProperties") {
            if (!result[name]) {
              result[name] = /* @__PURE__ */ Object.create(null);
            }
            const currentUserProperty = this._parseByType(constants.propertiesTypes[name]);
            if (result[name][currentUserProperty.name]) {
              if (Array.isArray(result[name][currentUserProperty.name])) {
                result[name][currentUserProperty.name].push(currentUserProperty.value);
              } else {
                const currentValue = result[name][currentUserProperty.name];
                result[name][currentUserProperty.name] = [currentValue];
                result[name][currentUserProperty.name].push(currentUserProperty.value);
              }
            } else {
              result[name][currentUserProperty.name] = currentUserProperty.value;
            }
            continue;
          }
          if (result[name]) {
            if (Array.isArray(result[name])) {
              result[name].push(this._parseByType(constants.propertiesTypes[name]));
            } else {
              result[name] = [result[name]];
              result[name].push(this._parseByType(constants.propertiesTypes[name]));
            }
          } else {
            result[name] = this._parseByType(constants.propertiesTypes[name]);
          }
        }
        return result;
      }
      _newPacket() {
        debug("_newPacket");
        if (this.packet) {
          this._list.consume(this.packet.length);
          debug("_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d", this.packet.cmd, this.packet.payload, this.packet.length);
          this.emit("packet", this.packet);
        }
        debug("_newPacket: new packet");
        this.packet = new Packet();
        this._pos = 0;
        return true;
      }
      _emitError(err) {
        debug("_emitError");
        this.error = err;
        this.emit("error", err);
      }
    };
    module.exports = Parser;
  }
});

// node_modules/mqtt-packet/numbers.js
var require_numbers = __commonJS({
  "node_modules/mqtt-packet/numbers.js"(exports, module) {
    init_shim();
    var max = 65536;
    var cache = {};
    var SubOk = import_buffer.Buffer.isBuffer(import_buffer.Buffer.from([1, 2]).subarray(0, 1));
    function generateBuffer(i) {
      const buffer = import_buffer.Buffer.allocUnsafe(2);
      buffer.writeUInt8(i >> 8, 0);
      buffer.writeUInt8(i & 255, 0 + 1);
      return buffer;
    }
    function generateCache() {
      for (let i = 0; i < max; i++) {
        cache[i] = generateBuffer(i);
      }
    }
    function genBufVariableByteInt(num) {
      const maxLength = 4;
      let digit = 0;
      let pos = 0;
      const buffer = import_buffer.Buffer.allocUnsafe(maxLength);
      do {
        digit = num % 128 | 0;
        num = num / 128 | 0;
        if (num > 0)
          digit = digit | 128;
        buffer.writeUInt8(digit, pos++);
      } while (num > 0 && pos < maxLength);
      if (num > 0) {
        pos = 0;
      }
      return SubOk ? buffer.subarray(0, pos) : buffer.slice(0, pos);
    }
    function generate4ByteBuffer(num) {
      const buffer = import_buffer.Buffer.allocUnsafe(4);
      buffer.writeUInt32BE(num, 0);
      return buffer;
    }
    module.exports = {
      cache,
      generateCache,
      generateNumber: generateBuffer,
      genBufVariableByteInt,
      generate4ByteBuffer
    };
  }
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "node_modules/process-nextick-args/index.js"(exports, module) {
    "use strict";
    init_shim();
    if (typeof import_process.default === "undefined" || !import_process.default.version || import_process.default.version.indexOf("v0.") === 0 || import_process.default.version.indexOf("v1.") === 0 && import_process.default.version.indexOf("v1.8.") !== 0) {
      module.exports = { nextTick };
    } else {
      module.exports = import_process.default;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return import_process.default.nextTick(fn);
        case 2:
          return import_process.default.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return import_process.default.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return import_process.default.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return import_process.default.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  }
});

// node_modules/mqtt-packet/writeToStream.js
var require_writeToStream = __commonJS({
  "node_modules/mqtt-packet/writeToStream.js"(exports, module) {
    init_shim();
    var protocol = require_constants();
    var empty2 = import_buffer.Buffer.allocUnsafe(0);
    var zeroBuf = import_buffer.Buffer.from([0]);
    var numbers = require_numbers();
    var nextTick = require_process_nextick_args().nextTick;
    var debug = require_browser2()("mqtt-packet:writeToStream");
    var numCache = numbers.cache;
    var generateNumber = numbers.generateNumber;
    var generateCache = numbers.generateCache;
    var genBufVariableByteInt = numbers.genBufVariableByteInt;
    var generate4ByteBuffer = numbers.generate4ByteBuffer;
    var writeNumber = writeNumberCached;
    var toGenerate = true;
    function generate(packet, stream, opts) {
      debug("generate called");
      if (stream.cork) {
        stream.cork();
        nextTick(uncork, stream);
      }
      if (toGenerate) {
        toGenerate = false;
        generateCache();
      }
      debug("generate: packet.cmd: %s", packet.cmd);
      switch (packet.cmd) {
        case "connect":
          return connect(packet, stream, opts);
        case "connack":
          return connack(packet, stream, opts);
        case "publish":
          return publish(packet, stream, opts);
        case "puback":
        case "pubrec":
        case "pubrel":
        case "pubcomp":
          return confirmation(packet, stream, opts);
        case "subscribe":
          return subscribe(packet, stream, opts);
        case "suback":
          return suback(packet, stream, opts);
        case "unsubscribe":
          return unsubscribe(packet, stream, opts);
        case "unsuback":
          return unsuback(packet, stream, opts);
        case "pingreq":
        case "pingresp":
          return emptyPacket(packet, stream, opts);
        case "disconnect":
          return disconnect(packet, stream, opts);
        case "auth":
          return auth(packet, stream, opts);
        default:
          stream.emit("error", new Error("Unknown command"));
          return false;
      }
    }
    Object.defineProperty(generate, "cacheNumbers", {
      get() {
        return writeNumber === writeNumberCached;
      },
      set(value) {
        if (value) {
          if (!numCache || Object.keys(numCache).length === 0)
            toGenerate = true;
          writeNumber = writeNumberCached;
        } else {
          toGenerate = false;
          writeNumber = writeNumberGenerated;
        }
      }
    });
    function uncork(stream) {
      stream.uncork();
    }
    function connect(packet, stream, opts) {
      const settings = packet || {};
      const protocolId = settings.protocolId || "MQTT";
      let protocolVersion = settings.protocolVersion || 4;
      const will = settings.will;
      let clean = settings.clean;
      const keepalive = settings.keepalive || 0;
      const clientId = settings.clientId || "";
      const username = settings.username;
      const password = settings.password;
      const properties = settings.properties;
      if (clean === void 0)
        clean = true;
      let length = 0;
      if (!protocolId || typeof protocolId !== "string" && !import_buffer.Buffer.isBuffer(protocolId)) {
        stream.emit("error", new Error("Invalid protocolId"));
        return false;
      } else
        length += protocolId.length + 2;
      if (protocolVersion !== 3 && protocolVersion !== 4 && protocolVersion !== 5) {
        stream.emit("error", new Error("Invalid protocol version"));
        return false;
      } else
        length += 1;
      if ((typeof clientId === "string" || import_buffer.Buffer.isBuffer(clientId)) && (clientId || protocolVersion >= 4) && (clientId || clean)) {
        length += import_buffer.Buffer.byteLength(clientId) + 2;
      } else {
        if (protocolVersion < 4) {
          stream.emit("error", new Error("clientId must be supplied before 3.1.1"));
          return false;
        }
        if (clean * 1 === 0) {
          stream.emit("error", new Error("clientId must be given if cleanSession set to 0"));
          return false;
        }
      }
      if (typeof keepalive !== "number" || keepalive < 0 || keepalive > 65535 || keepalive % 1 !== 0) {
        stream.emit("error", new Error("Invalid keepalive"));
        return false;
      } else
        length += 2;
      length += 1;
      if (protocolVersion === 5) {
        var propertiesData = getProperties(stream, properties);
        if (!propertiesData) {
          return false;
        }
        length += propertiesData.length;
      }
      if (will) {
        if (typeof will !== "object") {
          stream.emit("error", new Error("Invalid will"));
          return false;
        }
        if (!will.topic || typeof will.topic !== "string") {
          stream.emit("error", new Error("Invalid will topic"));
          return false;
        } else {
          length += import_buffer.Buffer.byteLength(will.topic) + 2;
        }
        length += 2;
        if (will.payload) {
          if (will.payload.length >= 0) {
            if (typeof will.payload === "string") {
              length += import_buffer.Buffer.byteLength(will.payload);
            } else {
              length += will.payload.length;
            }
          } else {
            stream.emit("error", new Error("Invalid will payload"));
            return false;
          }
        }
        var willProperties = {};
        if (protocolVersion === 5) {
          willProperties = getProperties(stream, will.properties);
          if (!willProperties) {
            return false;
          }
          length += willProperties.length;
        }
      }
      let providedUsername = false;
      if (username != null) {
        if (isStringOrBuffer(username)) {
          providedUsername = true;
          length += import_buffer.Buffer.byteLength(username) + 2;
        } else {
          stream.emit("error", new Error("Invalid username"));
          return false;
        }
      }
      if (password != null) {
        if (!providedUsername) {
          stream.emit("error", new Error("Username is required to use password"));
          return false;
        }
        if (isStringOrBuffer(password)) {
          length += byteLength(password) + 2;
        } else {
          stream.emit("error", new Error("Invalid password"));
          return false;
        }
      }
      stream.write(protocol.CONNECT_HEADER);
      writeVarByteInt(stream, length);
      writeStringOrBuffer(stream, protocolId);
      if (settings.bridgeMode) {
        protocolVersion += 128;
      }
      stream.write(
        protocolVersion === 131 ? protocol.VERSION131 : protocolVersion === 132 ? protocol.VERSION132 : protocolVersion === 4 ? protocol.VERSION4 : protocolVersion === 5 ? protocol.VERSION5 : protocol.VERSION3
      );
      let flags = 0;
      flags |= username != null ? protocol.USERNAME_MASK : 0;
      flags |= password != null ? protocol.PASSWORD_MASK : 0;
      flags |= will && will.retain ? protocol.WILL_RETAIN_MASK : 0;
      flags |= will && will.qos ? will.qos << protocol.WILL_QOS_SHIFT : 0;
      flags |= will ? protocol.WILL_FLAG_MASK : 0;
      flags |= clean ? protocol.CLEAN_SESSION_MASK : 0;
      stream.write(import_buffer.Buffer.from([flags]));
      writeNumber(stream, keepalive);
      if (protocolVersion === 5) {
        propertiesData.write();
      }
      writeStringOrBuffer(stream, clientId);
      if (will) {
        if (protocolVersion === 5) {
          willProperties.write();
        }
        writeString(stream, will.topic);
        writeStringOrBuffer(stream, will.payload);
      }
      if (username != null) {
        writeStringOrBuffer(stream, username);
      }
      if (password != null) {
        writeStringOrBuffer(stream, password);
      }
      return true;
    }
    function connack(packet, stream, opts) {
      const version = opts ? opts.protocolVersion : 4;
      const settings = packet || {};
      const rc = version === 5 ? settings.reasonCode : settings.returnCode;
      const properties = settings.properties;
      let length = 2;
      if (typeof rc !== "number") {
        stream.emit("error", new Error("Invalid return code"));
        return false;
      }
      let propertiesData = null;
      if (version === 5) {
        propertiesData = getProperties(stream, properties);
        if (!propertiesData) {
          return false;
        }
        length += propertiesData.length;
      }
      stream.write(protocol.CONNACK_HEADER);
      writeVarByteInt(stream, length);
      stream.write(settings.sessionPresent ? protocol.SESSIONPRESENT_HEADER : zeroBuf);
      stream.write(import_buffer.Buffer.from([rc]));
      if (propertiesData != null) {
        propertiesData.write();
      }
      return true;
    }
    function publish(packet, stream, opts) {
      debug("publish: packet: %o", packet);
      const version = opts ? opts.protocolVersion : 4;
      const settings = packet || {};
      const qos = settings.qos || 0;
      const retain = settings.retain ? protocol.RETAIN_MASK : 0;
      const topic = settings.topic;
      const payload = settings.payload || empty2;
      const id = settings.messageId;
      const properties = settings.properties;
      let length = 0;
      if (typeof topic === "string")
        length += import_buffer.Buffer.byteLength(topic) + 2;
      else if (import_buffer.Buffer.isBuffer(topic))
        length += topic.length + 2;
      else {
        stream.emit("error", new Error("Invalid topic"));
        return false;
      }
      if (!import_buffer.Buffer.isBuffer(payload))
        length += import_buffer.Buffer.byteLength(payload);
      else
        length += payload.length;
      if (qos && typeof id !== "number") {
        stream.emit("error", new Error("Invalid messageId"));
        return false;
      } else if (qos)
        length += 2;
      let propertiesData = null;
      if (version === 5) {
        propertiesData = getProperties(stream, properties);
        if (!propertiesData) {
          return false;
        }
        length += propertiesData.length;
      }
      stream.write(protocol.PUBLISH_HEADER[qos][settings.dup ? 1 : 0][retain ? 1 : 0]);
      writeVarByteInt(stream, length);
      writeNumber(stream, byteLength(topic));
      stream.write(topic);
      if (qos > 0)
        writeNumber(stream, id);
      if (propertiesData != null) {
        propertiesData.write();
      }
      debug("publish: payload: %o", payload);
      return stream.write(payload);
    }
    function confirmation(packet, stream, opts) {
      const version = opts ? opts.protocolVersion : 4;
      const settings = packet || {};
      const type = settings.cmd || "puback";
      const id = settings.messageId;
      const dup = settings.dup && type === "pubrel" ? protocol.DUP_MASK : 0;
      let qos = 0;
      const reasonCode = settings.reasonCode;
      const properties = settings.properties;
      let length = version === 5 ? 3 : 2;
      if (type === "pubrel")
        qos = 1;
      if (typeof id !== "number") {
        stream.emit("error", new Error("Invalid messageId"));
        return false;
      }
      let propertiesData = null;
      if (version === 5) {
        if (typeof properties === "object") {
          propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);
          if (!propertiesData) {
            return false;
          }
          length += propertiesData.length;
        }
      }
      stream.write(protocol.ACKS[type][qos][dup][0]);
      writeVarByteInt(stream, length);
      writeNumber(stream, id);
      if (version === 5) {
        stream.write(import_buffer.Buffer.from([reasonCode]));
      }
      if (propertiesData !== null) {
        propertiesData.write();
      }
      return true;
    }
    function subscribe(packet, stream, opts) {
      debug("subscribe: packet: ");
      const version = opts ? opts.protocolVersion : 4;
      const settings = packet || {};
      const dup = settings.dup ? protocol.DUP_MASK : 0;
      const id = settings.messageId;
      const subs = settings.subscriptions;
      const properties = settings.properties;
      let length = 0;
      if (typeof id !== "number") {
        stream.emit("error", new Error("Invalid messageId"));
        return false;
      } else
        length += 2;
      let propertiesData = null;
      if (version === 5) {
        propertiesData = getProperties(stream, properties);
        if (!propertiesData) {
          return false;
        }
        length += propertiesData.length;
      }
      if (typeof subs === "object" && subs.length) {
        for (let i = 0; i < subs.length; i += 1) {
          const itopic = subs[i].topic;
          const iqos = subs[i].qos;
          if (typeof itopic !== "string") {
            stream.emit("error", new Error("Invalid subscriptions - invalid topic"));
            return false;
          }
          if (typeof iqos !== "number") {
            stream.emit("error", new Error("Invalid subscriptions - invalid qos"));
            return false;
          }
          if (version === 5) {
            const nl = subs[i].nl || false;
            if (typeof nl !== "boolean") {
              stream.emit("error", new Error("Invalid subscriptions - invalid No Local"));
              return false;
            }
            const rap = subs[i].rap || false;
            if (typeof rap !== "boolean") {
              stream.emit("error", new Error("Invalid subscriptions - invalid Retain as Published"));
              return false;
            }
            const rh = subs[i].rh || 0;
            if (typeof rh !== "number" || rh > 2) {
              stream.emit("error", new Error("Invalid subscriptions - invalid Retain Handling"));
              return false;
            }
          }
          length += import_buffer.Buffer.byteLength(itopic) + 2 + 1;
        }
      } else {
        stream.emit("error", new Error("Invalid subscriptions"));
        return false;
      }
      debug("subscribe: writing to stream: %o", protocol.SUBSCRIBE_HEADER);
      stream.write(protocol.SUBSCRIBE_HEADER[1][dup ? 1 : 0][0]);
      writeVarByteInt(stream, length);
      writeNumber(stream, id);
      if (propertiesData !== null) {
        propertiesData.write();
      }
      let result = true;
      for (const sub of subs) {
        const jtopic = sub.topic;
        const jqos = sub.qos;
        const jnl = +sub.nl;
        const jrap = +sub.rap;
        const jrh = sub.rh;
        let joptions;
        writeString(stream, jtopic);
        joptions = protocol.SUBSCRIBE_OPTIONS_QOS[jqos];
        if (version === 5) {
          joptions |= jnl ? protocol.SUBSCRIBE_OPTIONS_NL : 0;
          joptions |= jrap ? protocol.SUBSCRIBE_OPTIONS_RAP : 0;
          joptions |= jrh ? protocol.SUBSCRIBE_OPTIONS_RH[jrh] : 0;
        }
        result = stream.write(import_buffer.Buffer.from([joptions]));
      }
      return result;
    }
    function suback(packet, stream, opts) {
      const version = opts ? opts.protocolVersion : 4;
      const settings = packet || {};
      const id = settings.messageId;
      const granted = settings.granted;
      const properties = settings.properties;
      let length = 0;
      if (typeof id !== "number") {
        stream.emit("error", new Error("Invalid messageId"));
        return false;
      } else
        length += 2;
      if (typeof granted === "object" && granted.length) {
        for (let i = 0; i < granted.length; i += 1) {
          if (typeof granted[i] !== "number") {
            stream.emit("error", new Error("Invalid qos vector"));
            return false;
          }
          length += 1;
        }
      } else {
        stream.emit("error", new Error("Invalid qos vector"));
        return false;
      }
      let propertiesData = null;
      if (version === 5) {
        propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);
        if (!propertiesData) {
          return false;
        }
        length += propertiesData.length;
      }
      stream.write(protocol.SUBACK_HEADER);
      writeVarByteInt(stream, length);
      writeNumber(stream, id);
      if (propertiesData !== null) {
        propertiesData.write();
      }
      return stream.write(import_buffer.Buffer.from(granted));
    }
    function unsubscribe(packet, stream, opts) {
      const version = opts ? opts.protocolVersion : 4;
      const settings = packet || {};
      const id = settings.messageId;
      const dup = settings.dup ? protocol.DUP_MASK : 0;
      const unsubs = settings.unsubscriptions;
      const properties = settings.properties;
      let length = 0;
      if (typeof id !== "number") {
        stream.emit("error", new Error("Invalid messageId"));
        return false;
      } else {
        length += 2;
      }
      if (typeof unsubs === "object" && unsubs.length) {
        for (let i = 0; i < unsubs.length; i += 1) {
          if (typeof unsubs[i] !== "string") {
            stream.emit("error", new Error("Invalid unsubscriptions"));
            return false;
          }
          length += import_buffer.Buffer.byteLength(unsubs[i]) + 2;
        }
      } else {
        stream.emit("error", new Error("Invalid unsubscriptions"));
        return false;
      }
      let propertiesData = null;
      if (version === 5) {
        propertiesData = getProperties(stream, properties);
        if (!propertiesData) {
          return false;
        }
        length += propertiesData.length;
      }
      stream.write(protocol.UNSUBSCRIBE_HEADER[1][dup ? 1 : 0][0]);
      writeVarByteInt(stream, length);
      writeNumber(stream, id);
      if (propertiesData !== null) {
        propertiesData.write();
      }
      let result = true;
      for (let j = 0; j < unsubs.length; j++) {
        result = writeString(stream, unsubs[j]);
      }
      return result;
    }
    function unsuback(packet, stream, opts) {
      const version = opts ? opts.protocolVersion : 4;
      const settings = packet || {};
      const id = settings.messageId;
      const dup = settings.dup ? protocol.DUP_MASK : 0;
      const granted = settings.granted;
      const properties = settings.properties;
      const type = settings.cmd;
      const qos = 0;
      let length = 2;
      if (typeof id !== "number") {
        stream.emit("error", new Error("Invalid messageId"));
        return false;
      }
      if (version === 5) {
        if (typeof granted === "object" && granted.length) {
          for (let i = 0; i < granted.length; i += 1) {
            if (typeof granted[i] !== "number") {
              stream.emit("error", new Error("Invalid qos vector"));
              return false;
            }
            length += 1;
          }
        } else {
          stream.emit("error", new Error("Invalid qos vector"));
          return false;
        }
      }
      let propertiesData = null;
      if (version === 5) {
        propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);
        if (!propertiesData) {
          return false;
        }
        length += propertiesData.length;
      }
      stream.write(protocol.ACKS[type][qos][dup][0]);
      writeVarByteInt(stream, length);
      writeNumber(stream, id);
      if (propertiesData !== null) {
        propertiesData.write();
      }
      if (version === 5) {
        stream.write(import_buffer.Buffer.from(granted));
      }
      return true;
    }
    function emptyPacket(packet, stream, opts) {
      return stream.write(protocol.EMPTY[packet.cmd]);
    }
    function disconnect(packet, stream, opts) {
      const version = opts ? opts.protocolVersion : 4;
      const settings = packet || {};
      const reasonCode = settings.reasonCode;
      const properties = settings.properties;
      let length = version === 5 ? 1 : 0;
      let propertiesData = null;
      if (version === 5) {
        propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);
        if (!propertiesData) {
          return false;
        }
        length += propertiesData.length;
      }
      stream.write(import_buffer.Buffer.from([protocol.codes.disconnect << 4]));
      writeVarByteInt(stream, length);
      if (version === 5) {
        stream.write(import_buffer.Buffer.from([reasonCode]));
      }
      if (propertiesData !== null) {
        propertiesData.write();
      }
      return true;
    }
    function auth(packet, stream, opts) {
      const version = opts ? opts.protocolVersion : 4;
      const settings = packet || {};
      const reasonCode = settings.reasonCode;
      const properties = settings.properties;
      let length = version === 5 ? 1 : 0;
      if (version !== 5)
        stream.emit("error", new Error("Invalid mqtt version for auth packet"));
      const propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);
      if (!propertiesData) {
        return false;
      }
      length += propertiesData.length;
      stream.write(import_buffer.Buffer.from([protocol.codes.auth << 4]));
      writeVarByteInt(stream, length);
      stream.write(import_buffer.Buffer.from([reasonCode]));
      if (propertiesData !== null) {
        propertiesData.write();
      }
      return true;
    }
    var varByteIntCache = {};
    function writeVarByteInt(stream, num) {
      if (num > protocol.VARBYTEINT_MAX) {
        stream.emit("error", new Error(`Invalid variable byte integer: ${num}`));
        return false;
      }
      let buffer = varByteIntCache[num];
      if (!buffer) {
        buffer = genBufVariableByteInt(num);
        if (num < 16384)
          varByteIntCache[num] = buffer;
      }
      debug("writeVarByteInt: writing to stream: %o", buffer);
      return stream.write(buffer);
    }
    function writeString(stream, string) {
      const strlen = import_buffer.Buffer.byteLength(string);
      writeNumber(stream, strlen);
      debug("writeString: %s", string);
      return stream.write(string, "utf8");
    }
    function writeStringPair(stream, name, value) {
      writeString(stream, name);
      writeString(stream, value);
    }
    function writeNumberCached(stream, number) {
      debug("writeNumberCached: number: %d", number);
      debug("writeNumberCached: %o", numCache[number]);
      return stream.write(numCache[number]);
    }
    function writeNumberGenerated(stream, number) {
      const generatedNumber = generateNumber(number);
      debug("writeNumberGenerated: %o", generatedNumber);
      return stream.write(generatedNumber);
    }
    function write4ByteNumber(stream, number) {
      const generated4ByteBuffer = generate4ByteBuffer(number);
      debug("write4ByteNumber: %o", generated4ByteBuffer);
      return stream.write(generated4ByteBuffer);
    }
    function writeStringOrBuffer(stream, toWrite) {
      if (typeof toWrite === "string") {
        writeString(stream, toWrite);
      } else if (toWrite) {
        writeNumber(stream, toWrite.length);
        stream.write(toWrite);
      } else
        writeNumber(stream, 0);
    }
    function getProperties(stream, properties) {
      if (typeof properties !== "object" || properties.length != null) {
        return {
          length: 1,
          write() {
            writeProperties(stream, {}, 0);
          }
        };
      }
      let propertiesLength = 0;
      function getLengthProperty(name, value) {
        const type = protocol.propertiesTypes[name];
        let length = 0;
        switch (type) {
          case "byte": {
            if (typeof value !== "boolean") {
              stream.emit("error", new Error(`Invalid ${name}: ${value}`));
              return false;
            }
            length += 1 + 1;
            break;
          }
          case "int8": {
            if (typeof value !== "number" || value < 0 || value > 255) {
              stream.emit("error", new Error(`Invalid ${name}: ${value}`));
              return false;
            }
            length += 1 + 1;
            break;
          }
          case "binary": {
            if (value && value === null) {
              stream.emit("error", new Error(`Invalid ${name}: ${value}`));
              return false;
            }
            length += 1 + import_buffer.Buffer.byteLength(value) + 2;
            break;
          }
          case "int16": {
            if (typeof value !== "number" || value < 0 || value > 65535) {
              stream.emit("error", new Error(`Invalid ${name}: ${value}`));
              return false;
            }
            length += 1 + 2;
            break;
          }
          case "int32": {
            if (typeof value !== "number" || value < 0 || value > 4294967295) {
              stream.emit("error", new Error(`Invalid ${name}: ${value}`));
              return false;
            }
            length += 1 + 4;
            break;
          }
          case "var": {
            if (typeof value !== "number" || value < 0 || value > 268435455) {
              stream.emit("error", new Error(`Invalid ${name}: ${value}`));
              return false;
            }
            length += 1 + import_buffer.Buffer.byteLength(genBufVariableByteInt(value));
            break;
          }
          case "string": {
            if (typeof value !== "string") {
              stream.emit("error", new Error(`Invalid ${name}: ${value}`));
              return false;
            }
            length += 1 + 2 + import_buffer.Buffer.byteLength(value.toString());
            break;
          }
          case "pair": {
            if (typeof value !== "object") {
              stream.emit("error", new Error(`Invalid ${name}: ${value}`));
              return false;
            }
            length += Object.getOwnPropertyNames(value).reduce((result, name2) => {
              const currentValue = value[name2];
              if (Array.isArray(currentValue)) {
                result += currentValue.reduce((currentLength, value2) => {
                  currentLength += 1 + 2 + import_buffer.Buffer.byteLength(name2.toString()) + 2 + import_buffer.Buffer.byteLength(value2.toString());
                  return currentLength;
                }, 0);
              } else {
                result += 1 + 2 + import_buffer.Buffer.byteLength(name2.toString()) + 2 + import_buffer.Buffer.byteLength(value[name2].toString());
              }
              return result;
            }, 0);
            break;
          }
          default: {
            stream.emit("error", new Error(`Invalid property ${name}: ${value}`));
            return false;
          }
        }
        return length;
      }
      if (properties) {
        for (const propName in properties) {
          let propLength = 0;
          let propValueLength = 0;
          const propValue = properties[propName];
          if (Array.isArray(propValue)) {
            for (let valueIndex = 0; valueIndex < propValue.length; valueIndex++) {
              propValueLength = getLengthProperty(propName, propValue[valueIndex]);
              if (!propValueLength) {
                return false;
              }
              propLength += propValueLength;
            }
          } else {
            propValueLength = getLengthProperty(propName, propValue);
            if (!propValueLength) {
              return false;
            }
            propLength = propValueLength;
          }
          if (!propLength)
            return false;
          propertiesLength += propLength;
        }
      }
      const propertiesLengthLength = import_buffer.Buffer.byteLength(genBufVariableByteInt(propertiesLength));
      return {
        length: propertiesLengthLength + propertiesLength,
        write() {
          writeProperties(stream, properties, propertiesLength);
        }
      };
    }
    function getPropertiesByMaximumPacketSize(stream, properties, opts, length) {
      const mayEmptyProps = ["reasonString", "userProperties"];
      const maximumPacketSize = opts && opts.properties && opts.properties.maximumPacketSize ? opts.properties.maximumPacketSize : 0;
      let propertiesData = getProperties(stream, properties);
      if (maximumPacketSize) {
        while (length + propertiesData.length > maximumPacketSize) {
          const currentMayEmptyProp = mayEmptyProps.shift();
          if (currentMayEmptyProp && properties[currentMayEmptyProp]) {
            delete properties[currentMayEmptyProp];
            propertiesData = getProperties(stream, properties);
          } else {
            return false;
          }
        }
      }
      return propertiesData;
    }
    function writeProperty(stream, propName, value) {
      const type = protocol.propertiesTypes[propName];
      switch (type) {
        case "byte": {
          stream.write(import_buffer.Buffer.from([protocol.properties[propName]]));
          stream.write(import_buffer.Buffer.from([+value]));
          break;
        }
        case "int8": {
          stream.write(import_buffer.Buffer.from([protocol.properties[propName]]));
          stream.write(import_buffer.Buffer.from([value]));
          break;
        }
        case "binary": {
          stream.write(import_buffer.Buffer.from([protocol.properties[propName]]));
          writeStringOrBuffer(stream, value);
          break;
        }
        case "int16": {
          stream.write(import_buffer.Buffer.from([protocol.properties[propName]]));
          writeNumber(stream, value);
          break;
        }
        case "int32": {
          stream.write(import_buffer.Buffer.from([protocol.properties[propName]]));
          write4ByteNumber(stream, value);
          break;
        }
        case "var": {
          stream.write(import_buffer.Buffer.from([protocol.properties[propName]]));
          writeVarByteInt(stream, value);
          break;
        }
        case "string": {
          stream.write(import_buffer.Buffer.from([protocol.properties[propName]]));
          writeString(stream, value);
          break;
        }
        case "pair": {
          Object.getOwnPropertyNames(value).forEach((name) => {
            const currentValue = value[name];
            if (Array.isArray(currentValue)) {
              currentValue.forEach((value2) => {
                stream.write(import_buffer.Buffer.from([protocol.properties[propName]]));
                writeStringPair(stream, name.toString(), value2.toString());
              });
            } else {
              stream.write(import_buffer.Buffer.from([protocol.properties[propName]]));
              writeStringPair(stream, name.toString(), currentValue.toString());
            }
          });
          break;
        }
        default: {
          stream.emit("error", new Error(`Invalid property ${propName} value: ${value}`));
          return false;
        }
      }
    }
    function writeProperties(stream, properties, propertiesLength) {
      writeVarByteInt(stream, propertiesLength);
      for (const propName in properties) {
        if (Object.prototype.hasOwnProperty.call(properties, propName) && properties[propName] !== null) {
          const value = properties[propName];
          if (Array.isArray(value)) {
            for (let valueIndex = 0; valueIndex < value.length; valueIndex++) {
              writeProperty(stream, propName, value[valueIndex]);
            }
          } else {
            writeProperty(stream, propName, value);
          }
        }
      }
    }
    function byteLength(bufOrString) {
      if (!bufOrString)
        return 0;
      else if (bufOrString instanceof import_buffer.Buffer)
        return bufOrString.length;
      else
        return import_buffer.Buffer.byteLength(bufOrString);
    }
    function isStringOrBuffer(field) {
      return typeof field === "string" || field instanceof import_buffer.Buffer;
    }
    module.exports = generate;
  }
});

// node_modules/mqtt-packet/generate.js
var require_generate = __commonJS({
  "node_modules/mqtt-packet/generate.js"(exports, module) {
    init_shim();
    var writeToStream = require_writeToStream();
    var EventEmitter = require_events();
    function generate(packet, opts) {
      const stream = new Accumulator();
      writeToStream(packet, stream, opts);
      return stream.concat();
    }
    var Accumulator = class extends EventEmitter {
      constructor() {
        super();
        this._array = new Array(20);
        this._i = 0;
      }
      write(chunk) {
        this._array[this._i++] = chunk;
        return true;
      }
      concat() {
        let length = 0;
        const lengths = new Array(this._array.length);
        const list = this._array;
        let pos = 0;
        let i;
        for (i = 0; i < list.length && list[i] !== void 0; i++) {
          if (typeof list[i] !== "string")
            lengths[i] = list[i].length;
          else
            lengths[i] = import_buffer.Buffer.byteLength(list[i]);
          length += lengths[i];
        }
        const result = import_buffer.Buffer.allocUnsafe(length);
        for (i = 0; i < list.length && list[i] !== void 0; i++) {
          if (typeof list[i] !== "string") {
            list[i].copy(result, pos);
            pos += lengths[i];
          } else {
            result.write(list[i], pos);
            pos += lengths[i];
          }
        }
        return result;
      }
    };
    module.exports = generate;
  }
});

// node_modules/mqtt-packet/mqtt.js
var require_mqtt = __commonJS({
  "node_modules/mqtt-packet/mqtt.js"(exports) {
    init_shim();
    exports.parser = require_parser().parser;
    exports.generate = require_generate();
    exports.writeToStream = require_writeToStream();
  }
});

// node_modules/mqtt/lib/default-message-id-provider.js
var require_default_message_id_provider = __commonJS({
  "node_modules/mqtt/lib/default-message-id-provider.js"(exports, module) {
    "use strict";
    init_shim();
    function DefaultMessageIdProvider() {
      if (!(this instanceof DefaultMessageIdProvider)) {
        return new DefaultMessageIdProvider();
      }
      this.nextId = Math.max(1, Math.floor(Math.random() * 65535));
    }
    DefaultMessageIdProvider.prototype.allocate = function() {
      const id = this.nextId++;
      if (this.nextId === 65536) {
        this.nextId = 1;
      }
      return id;
    };
    DefaultMessageIdProvider.prototype.getLastAllocated = function() {
      return this.nextId === 1 ? 65535 : this.nextId - 1;
    };
    DefaultMessageIdProvider.prototype.register = function(messageId) {
      return true;
    };
    DefaultMessageIdProvider.prototype.deallocate = function(messageId) {
    };
    DefaultMessageIdProvider.prototype.clear = function() {
    };
    module.exports = DefaultMessageIdProvider;
  }
});

// node_modules/reinterval/index.js
var require_reinterval = __commonJS({
  "node_modules/reinterval/index.js"(exports, module) {
    "use strict";
    init_shim();
    function ReInterval(callback, interval, args) {
      var self2 = this;
      this._callback = callback;
      this._args = args;
      this._interval = setInterval(callback, interval, this._args);
      this.reschedule = function(interval2) {
        if (!interval2)
          interval2 = self2._interval;
        if (self2._interval)
          clearInterval(self2._interval);
        self2._interval = setInterval(self2._callback, interval2, self2._args);
      };
      this.clear = function() {
        if (self2._interval) {
          clearInterval(self2._interval);
          self2._interval = void 0;
        }
      };
      this.destroy = function() {
        if (self2._interval) {
          clearInterval(self2._interval);
        }
        self2._callback = void 0;
        self2._interval = void 0;
        self2._args = void 0;
      };
    }
    function reInterval() {
      if (typeof arguments[0] !== "function")
        throw new Error("callback needed");
      if (typeof arguments[1] !== "number")
        throw new Error("interval needed");
      var args;
      if (arguments.length > 0) {
        args = new Array(arguments.length - 2);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 2];
        }
      }
      return new ReInterval(arguments[0], arguments[1], args);
    }
    module.exports = reInterval;
  }
});

// node_modules/rfdc/index.js
var require_rfdc = __commonJS({
  "node_modules/rfdc/index.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = rfdc;
    function copyBuffer(cur) {
      if (cur instanceof import_buffer.Buffer) {
        return import_buffer.Buffer.from(cur);
      }
      return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
    }
    function rfdc(opts) {
      opts = opts || {};
      if (opts.circles)
        return rfdcCircles(opts);
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn) {
        var keys = Object.keys(a);
        var a2 = new Array(keys.length);
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          var cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur instanceof Date) {
            a2[k] = new Date(cur);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            a2[k] = fn(cur);
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, clone);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), clone));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), clone));
        var o2 = {};
        for (var k in o) {
          if (Object.hasOwnProperty.call(o, k) === false)
            continue;
          var cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k] = new Map(cloneArray(Array.from(cur), clone));
          } else if (cur instanceof Set) {
            o2[k] = new Set(cloneArray(Array.from(cur), clone));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = clone(cur);
          }
        }
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, cloneProto);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), cloneProto));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), cloneProto));
        var o2 = {};
        for (var k in o) {
          var cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k] = new Map(cloneArray(Array.from(cur), cloneProto));
          } else if (cur instanceof Set) {
            o2[k] = new Set(cloneArray(Array.from(cur), cloneProto));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = cloneProto(cur);
          }
        }
        return o2;
      }
    }
    function rfdcCircles(opts) {
      var refs = [];
      var refsNew = [];
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn) {
        var keys = Object.keys(a);
        var a2 = new Array(keys.length);
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          var cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur instanceof Date) {
            a2[k] = new Date(cur);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            var index = refs.indexOf(cur);
            if (index !== -1) {
              a2[k] = refsNew[index];
            } else {
              a2[k] = fn(cur);
            }
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, clone);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), clone));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), clone));
        var o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (var k in o) {
          if (Object.hasOwnProperty.call(o, k) === false)
            continue;
          var cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k] = new Map(cloneArray(Array.from(cur), clone));
          } else if (cur instanceof Set) {
            o2[k] = new Set(cloneArray(Array.from(cur), clone));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            var i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = clone(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, cloneProto);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), cloneProto));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), cloneProto));
        var o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (var k in o) {
          var cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k] = new Map(cloneArray(Array.from(cur), cloneProto));
          } else if (cur instanceof Set) {
            o2[k] = new Set(cloneArray(Array.from(cur), cloneProto));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            var i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = cloneProto(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
    }
  }
});

// node_modules/rfdc/default.js
var require_default = __commonJS({
  "node_modules/rfdc/default.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = require_rfdc()();
  }
});

// node_modules/mqtt/lib/validations.js
var require_validations = __commonJS({
  "node_modules/mqtt/lib/validations.js"(exports, module) {
    "use strict";
    init_shim();
    function validateTopic(topic) {
      const parts = topic.split("/");
      for (let i = 0; i < parts.length; i++) {
        if (parts[i] === "+") {
          continue;
        }
        if (parts[i] === "#") {
          return i === parts.length - 1;
        }
        if (parts[i].indexOf("+") !== -1 || parts[i].indexOf("#") !== -1) {
          return false;
        }
      }
      return true;
    }
    function validateTopics(topics) {
      if (topics.length === 0) {
        return "empty_topic_list";
      }
      for (let i = 0; i < topics.length; i++) {
        if (!validateTopic(topics[i])) {
          return topics[i];
        }
      }
      return null;
    }
    module.exports = {
      validateTopics
    };
  }
});

// node_modules/mqtt/lib/client.js
var require_client = __commonJS({
  "node_modules/mqtt/lib/client.js"(exports, module) {
    "use strict";
    init_shim();
    var EventEmitter = require_events().EventEmitter;
    var Store = require_store();
    var TopicAliasRecv = require_topic_alias_recv();
    var TopicAliasSend = require_topic_alias_send();
    var mqttPacket = require_mqtt();
    var DefaultMessageIdProvider = require_default_message_id_provider();
    var Writable = require_readable_browser().Writable;
    var inherits = require_inherits_browser();
    var reInterval = require_reinterval();
    var clone = require_default();
    var validations = require_validations();
    var xtend = require_immutable();
    var debug = require_browser2()("mqttjs:client");
    var nextTick = import_process.default ? import_process.default.nextTick : function(callback) {
      setTimeout(callback, 0);
    };
    var setImmediate = _global.setImmediate || function(callback) {
      nextTick(callback);
    };
    var defaultConnectOptions = {
      keepalive: 60,
      reschedulePings: true,
      protocolId: "MQTT",
      protocolVersion: 4,
      reconnectPeriod: 1e3,
      connectTimeout: 30 * 1e3,
      clean: true,
      resubscribe: true
    };
    var socketErrors = [
      "ECONNREFUSED",
      "EADDRINUSE",
      "ECONNRESET",
      "ENOTFOUND"
    ];
    var errors = {
      0: "",
      1: "Unacceptable protocol version",
      2: "Identifier rejected",
      3: "Server unavailable",
      4: "Bad username or password",
      5: "Not authorized",
      16: "No matching subscribers",
      17: "No subscription existed",
      128: "Unspecified error",
      129: "Malformed Packet",
      130: "Protocol Error",
      131: "Implementation specific error",
      132: "Unsupported Protocol Version",
      133: "Client Identifier not valid",
      134: "Bad User Name or Password",
      135: "Not authorized",
      136: "Server unavailable",
      137: "Server busy",
      138: "Banned",
      139: "Server shutting down",
      140: "Bad authentication method",
      141: "Keep Alive timeout",
      142: "Session taken over",
      143: "Topic Filter invalid",
      144: "Topic Name invalid",
      145: "Packet identifier in use",
      146: "Packet Identifier not found",
      147: "Receive Maximum exceeded",
      148: "Topic Alias invalid",
      149: "Packet too large",
      150: "Message rate too high",
      151: "Quota exceeded",
      152: "Administrative action",
      153: "Payload format invalid",
      154: "Retain not supported",
      155: "QoS not supported",
      156: "Use another server",
      157: "Server moved",
      158: "Shared Subscriptions not supported",
      159: "Connection rate exceeded",
      160: "Maximum connect time",
      161: "Subscription Identifiers not supported",
      162: "Wildcard Subscriptions not supported"
    };
    function defaultId() {
      return "mqttjs_" + Math.random().toString(16).substr(2, 8);
    }
    function applyTopicAlias(client, packet) {
      if (client.options.protocolVersion === 5) {
        if (packet.cmd === "publish") {
          let alias;
          if (packet.properties) {
            alias = packet.properties.topicAlias;
          }
          const topic = packet.topic.toString();
          if (client.topicAliasSend) {
            if (alias) {
              if (topic.length !== 0) {
                debug("applyTopicAlias :: register topic: %s - alias: %d", topic, alias);
                if (!client.topicAliasSend.put(topic, alias)) {
                  debug("applyTopicAlias :: error out of range. topic: %s - alias: %d", topic, alias);
                  return new Error("Sending Topic Alias out of range");
                }
              }
            } else {
              if (topic.length !== 0) {
                if (client.options.autoAssignTopicAlias) {
                  alias = client.topicAliasSend.getAliasByTopic(topic);
                  if (alias) {
                    packet.topic = "";
                    packet.properties = { ...packet.properties, topicAlias: alias };
                    debug("applyTopicAlias :: auto assign(use) topic: %s - alias: %d", topic, alias);
                  } else {
                    alias = client.topicAliasSend.getLruAlias();
                    client.topicAliasSend.put(topic, alias);
                    packet.properties = { ...packet.properties, topicAlias: alias };
                    debug("applyTopicAlias :: auto assign topic: %s - alias: %d", topic, alias);
                  }
                } else if (client.options.autoUseTopicAlias) {
                  alias = client.topicAliasSend.getAliasByTopic(topic);
                  if (alias) {
                    packet.topic = "";
                    packet.properties = { ...packet.properties, topicAlias: alias };
                    debug("applyTopicAlias :: auto use topic: %s - alias: %d", topic, alias);
                  }
                }
              }
            }
          } else if (alias) {
            debug("applyTopicAlias :: error out of range. topic: %s - alias: %d", topic, alias);
            return new Error("Sending Topic Alias out of range");
          }
        }
      }
    }
    function removeTopicAliasAndRecoverTopicName(client, packet) {
      let alias;
      if (packet.properties) {
        alias = packet.properties.topicAlias;
      }
      let topic = packet.topic.toString();
      if (topic.length === 0) {
        if (typeof alias === "undefined") {
          return new Error("Unregistered Topic Alias");
        } else {
          topic = client.topicAliasSend.getTopicByAlias(alias);
          if (typeof topic === "undefined") {
            return new Error("Unregistered Topic Alias");
          } else {
            packet.topic = topic;
          }
        }
      }
      if (alias) {
        delete packet.properties.topicAlias;
      }
    }
    function sendPacket(client, packet, cb) {
      debug("sendPacket :: packet: %O", packet);
      debug("sendPacket :: emitting `packetsend`");
      client.emit("packetsend", packet);
      debug("sendPacket :: writing to stream");
      const result = mqttPacket.writeToStream(packet, client.stream, client.options);
      debug("sendPacket :: writeToStream result %s", result);
      if (!result && cb && cb !== nop) {
        debug("sendPacket :: handle events on `drain` once through callback.");
        client.stream.once("drain", cb);
      } else if (cb) {
        debug("sendPacket :: invoking cb");
        cb();
      }
    }
    function flush(queue) {
      if (queue) {
        debug("flush: queue exists? %b", !!queue);
        Object.keys(queue).forEach(function(messageId) {
          if (typeof queue[messageId].cb === "function") {
            queue[messageId].cb(new Error("Connection closed"));
            delete queue[messageId];
          }
        });
      }
    }
    function flushVolatile(queue) {
      if (queue) {
        debug("flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function");
        Object.keys(queue).forEach(function(messageId) {
          if (queue[messageId].volatile && typeof queue[messageId].cb === "function") {
            queue[messageId].cb(new Error("Connection closed"));
            delete queue[messageId];
          }
        });
      }
    }
    function storeAndSend(client, packet, cb, cbStorePut) {
      debug("storeAndSend :: store packet with cmd %s to outgoingStore", packet.cmd);
      let storePacket = packet;
      let err;
      if (storePacket.cmd === "publish") {
        storePacket = clone(packet);
        err = removeTopicAliasAndRecoverTopicName(client, storePacket);
        if (err) {
          return cb && cb(err);
        }
      }
      client.outgoingStore.put(storePacket, function storedPacket(err2) {
        if (err2) {
          return cb && cb(err2);
        }
        cbStorePut();
        sendPacket(client, packet, cb);
      });
    }
    function nop(error) {
      debug("nop ::", error);
    }
    function MqttClient(streamBuilder, options) {
      let k;
      const that = this;
      if (!(this instanceof MqttClient)) {
        return new MqttClient(streamBuilder, options);
      }
      this.options = options || {};
      for (k in defaultConnectOptions) {
        if (typeof this.options[k] === "undefined") {
          this.options[k] = defaultConnectOptions[k];
        } else {
          this.options[k] = options[k];
        }
      }
      debug("MqttClient :: options.protocol", options.protocol);
      debug("MqttClient :: options.protocolVersion", options.protocolVersion);
      debug("MqttClient :: options.username", options.username);
      debug("MqttClient :: options.keepalive", options.keepalive);
      debug("MqttClient :: options.reconnectPeriod", options.reconnectPeriod);
      debug("MqttClient :: options.rejectUnauthorized", options.rejectUnauthorized);
      debug("MqttClient :: options.topicAliasMaximum", options.topicAliasMaximum);
      this.options.clientId = typeof options.clientId === "string" ? options.clientId : defaultId();
      debug("MqttClient :: clientId", this.options.clientId);
      this.options.customHandleAcks = options.protocolVersion === 5 && options.customHandleAcks ? options.customHandleAcks : function() {
        arguments[3](0);
      };
      this.streamBuilder = streamBuilder;
      this.messageIdProvider = typeof this.options.messageIdProvider === "undefined" ? new DefaultMessageIdProvider() : this.options.messageIdProvider;
      this.outgoingStore = options.outgoingStore || new Store();
      this.incomingStore = options.incomingStore || new Store();
      this.queueQoSZero = options.queueQoSZero === void 0 ? true : options.queueQoSZero;
      this._resubscribeTopics = {};
      this.messageIdToTopic = {};
      this.pingTimer = null;
      this.connected = false;
      this.disconnecting = false;
      this.queue = [];
      this.connackTimer = null;
      this.reconnectTimer = null;
      this._storeProcessing = false;
      this._packetIdsDuringStoreProcessing = {};
      this._storeProcessingQueue = [];
      this.outgoing = {};
      this._firstConnection = true;
      if (options.topicAliasMaximum > 0) {
        if (options.topicAliasMaximum > 65535) {
          debug("MqttClient :: options.topicAliasMaximum is out of range");
        } else {
          this.topicAliasRecv = new TopicAliasRecv(options.topicAliasMaximum);
        }
      }
      this.on("connect", function() {
        const queue = this.queue;
        function deliver() {
          const entry = queue.shift();
          debug("deliver :: entry %o", entry);
          let packet = null;
          if (!entry) {
            that._resubscribe();
            return;
          }
          packet = entry.packet;
          debug("deliver :: call _sendPacket for %o", packet);
          let send = true;
          if (packet.messageId && packet.messageId !== 0) {
            if (!that.messageIdProvider.register(packet.messageId)) {
              send = false;
            }
          }
          if (send) {
            that._sendPacket(
              packet,
              function(err) {
                if (entry.cb) {
                  entry.cb(err);
                }
                deliver();
              }
            );
          } else {
            debug("messageId: %d has already used. The message is skipped and removed.", packet.messageId);
            deliver();
          }
        }
        debug("connect :: sending queued packets");
        deliver();
      });
      this.on("close", function() {
        debug("close :: connected set to `false`");
        this.connected = false;
        debug("close :: clearing connackTimer");
        clearTimeout(this.connackTimer);
        debug("close :: clearing ping timer");
        if (that.pingTimer !== null) {
          that.pingTimer.clear();
          that.pingTimer = null;
        }
        if (this.topicAliasRecv) {
          this.topicAliasRecv.clear();
        }
        debug("close :: calling _setupReconnect");
        this._setupReconnect();
      });
      EventEmitter.call(this);
      debug("MqttClient :: setting up stream");
      this._setupStream();
    }
    inherits(MqttClient, EventEmitter);
    MqttClient.prototype._setupStream = function() {
      const that = this;
      const writable = new Writable();
      const parser = mqttPacket.parser(this.options);
      let completeParse = null;
      const packets = [];
      debug("_setupStream :: calling method to clear reconnect");
      this._clearReconnect();
      debug("_setupStream :: using streamBuilder provided to client to create stream");
      this.stream = this.streamBuilder(this);
      parser.on("packet", function(packet) {
        debug("parser :: on packet push to packets array.");
        packets.push(packet);
      });
      function nextTickWork() {
        if (packets.length) {
          nextTick(work);
        } else {
          const done = completeParse;
          completeParse = null;
          done();
        }
      }
      function work() {
        debug("work :: getting next packet in queue");
        const packet = packets.shift();
        if (packet) {
          debug("work :: packet pulled from queue");
          that._handlePacket(packet, nextTickWork);
        } else {
          debug("work :: no packets in queue");
          const done = completeParse;
          completeParse = null;
          debug("work :: done flag is %s", !!done);
          if (done)
            done();
        }
      }
      writable._write = function(buf, enc, done) {
        completeParse = done;
        debug("writable stream :: parsing buffer");
        parser.parse(buf);
        work();
      };
      function streamErrorHandler(error) {
        debug("streamErrorHandler :: error", error.message);
        if (socketErrors.includes(error.code)) {
          debug("streamErrorHandler :: emitting error");
          that.emit("error", error);
        } else {
          nop(error);
        }
      }
      debug("_setupStream :: pipe stream to writable stream");
      this.stream.pipe(writable);
      this.stream.on("error", streamErrorHandler);
      this.stream.on("close", function() {
        debug("(%s)stream :: on close", that.options.clientId);
        flushVolatile(that.outgoing);
        debug("stream: emit close to MqttClient");
        that.emit("close");
      });
      debug("_setupStream: sending packet `connect`");
      const connectPacket = Object.create(this.options);
      connectPacket.cmd = "connect";
      if (this.topicAliasRecv) {
        if (!connectPacket.properties) {
          connectPacket.properties = {};
        }
        if (this.topicAliasRecv) {
          connectPacket.properties.topicAliasMaximum = this.topicAliasRecv.max;
        }
      }
      sendPacket(this, connectPacket);
      parser.on("error", this.emit.bind(this, "error"));
      if (this.options.properties) {
        if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) {
          that.end(() => this.emit(
            "error",
            new Error("Packet has no Authentication Method")
          ));
          return this;
        }
        if (this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket === "object") {
          const authPacket = xtend({ cmd: "auth", reasonCode: 0 }, this.options.authPacket);
          sendPacket(this, authPacket);
        }
      }
      this.stream.setMaxListeners(1e3);
      clearTimeout(this.connackTimer);
      this.connackTimer = setTimeout(function() {
        debug("!!connectTimeout hit!! Calling _cleanUp with force `true`");
        that._cleanUp(true);
      }, this.options.connectTimeout);
    };
    MqttClient.prototype._handlePacket = function(packet, done) {
      const options = this.options;
      if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {
        this.emit("error", new Error("exceeding packets size " + packet.cmd));
        this.end({ reasonCode: 149, properties: { reasonString: "Maximum packet size was exceeded" } });
        return this;
      }
      debug("_handlePacket :: emitting packetreceive");
      this.emit("packetreceive", packet);
      switch (packet.cmd) {
        case "publish":
          this._handlePublish(packet, done);
          break;
        case "puback":
        case "pubrec":
        case "pubcomp":
        case "suback":
        case "unsuback":
          this._handleAck(packet);
          done();
          break;
        case "pubrel":
          this._handlePubrel(packet, done);
          break;
        case "connack":
          this._handleConnack(packet);
          done();
          break;
        case "auth":
          this._handleAuth(packet);
          done();
          break;
        case "pingresp":
          this._handlePingresp(packet);
          done();
          break;
        case "disconnect":
          this._handleDisconnect(packet);
          done();
          break;
        default:
          break;
      }
    };
    MqttClient.prototype._checkDisconnecting = function(callback) {
      if (this.disconnecting) {
        if (callback && callback !== nop) {
          callback(new Error("client disconnecting"));
        } else {
          this.emit("error", new Error("client disconnecting"));
        }
      }
      return this.disconnecting;
    };
    MqttClient.prototype.publish = function(topic, message, opts, callback) {
      debug("publish :: message `%s` to topic `%s`", message, topic);
      const options = this.options;
      if (typeof opts === "function") {
        callback = opts;
        opts = null;
      }
      const defaultOpts = { qos: 0, retain: false, dup: false };
      opts = xtend(defaultOpts, opts);
      if (this._checkDisconnecting(callback)) {
        return this;
      }
      const that = this;
      const publishProc = function() {
        let messageId = 0;
        if (opts.qos === 1 || opts.qos === 2) {
          messageId = that._nextId();
          if (messageId === null) {
            debug("No messageId left");
            return false;
          }
        }
        const packet = {
          cmd: "publish",
          topic,
          payload: message,
          qos: opts.qos,
          retain: opts.retain,
          messageId,
          dup: opts.dup
        };
        if (options.protocolVersion === 5) {
          packet.properties = opts.properties;
        }
        debug("publish :: qos", opts.qos);
        switch (opts.qos) {
          case 1:
          case 2:
            that.outgoing[packet.messageId] = {
              volatile: false,
              cb: callback || nop
            };
            debug("MqttClient:publish: packet cmd: %s", packet.cmd);
            that._sendPacket(packet, void 0, opts.cbStorePut);
            break;
          default:
            debug("MqttClient:publish: packet cmd: %s", packet.cmd);
            that._sendPacket(packet, callback, opts.cbStorePut);
            break;
        }
        return true;
      };
      if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !publishProc()) {
        this._storeProcessingQueue.push(
          {
            invoke: publishProc,
            cbStorePut: opts.cbStorePut,
            callback
          }
        );
      }
      return this;
    };
    MqttClient.prototype.subscribe = function() {
      const that = this;
      const args = new Array(arguments.length);
      for (let i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }
      const subs = [];
      let obj = args.shift();
      const resubscribe = obj.resubscribe;
      let callback = args.pop() || nop;
      let opts = args.pop();
      const version = this.options.protocolVersion;
      delete obj.resubscribe;
      if (typeof obj === "string") {
        obj = [obj];
      }
      if (typeof callback !== "function") {
        opts = callback;
        callback = nop;
      }
      const invalidTopic = validations.validateTopics(obj);
      if (invalidTopic !== null) {
        setImmediate(callback, new Error("Invalid topic " + invalidTopic));
        return this;
      }
      if (this._checkDisconnecting(callback)) {
        debug("subscribe: discconecting true");
        return this;
      }
      const defaultOpts = {
        qos: 0
      };
      if (version === 5) {
        defaultOpts.nl = false;
        defaultOpts.rap = false;
        defaultOpts.rh = 0;
      }
      opts = xtend(defaultOpts, opts);
      if (Array.isArray(obj)) {
        obj.forEach(function(topic) {
          debug("subscribe: array topic %s", topic);
          if (!Object.prototype.hasOwnProperty.call(that._resubscribeTopics, topic) || that._resubscribeTopics[topic].qos < opts.qos || resubscribe) {
            const currentOpts = {
              topic,
              qos: opts.qos
            };
            if (version === 5) {
              currentOpts.nl = opts.nl;
              currentOpts.rap = opts.rap;
              currentOpts.rh = opts.rh;
              currentOpts.properties = opts.properties;
            }
            debug("subscribe: pushing topic `%s` and qos `%s` to subs list", currentOpts.topic, currentOpts.qos);
            subs.push(currentOpts);
          }
        });
      } else {
        Object.keys(obj).forEach(function(k) {
          debug("subscribe: object topic %s", k);
          if (!Object.prototype.hasOwnProperty.call(that._resubscribeTopics, k) || that._resubscribeTopics[k].qos < obj[k].qos || resubscribe) {
            const currentOpts = {
              topic: k,
              qos: obj[k].qos
            };
            if (version === 5) {
              currentOpts.nl = obj[k].nl;
              currentOpts.rap = obj[k].rap;
              currentOpts.rh = obj[k].rh;
              currentOpts.properties = opts.properties;
            }
            debug("subscribe: pushing `%s` to subs list", currentOpts);
            subs.push(currentOpts);
          }
        });
      }
      if (!subs.length) {
        callback(null, []);
        return this;
      }
      const subscribeProc = function() {
        const messageId = that._nextId();
        if (messageId === null) {
          debug("No messageId left");
          return false;
        }
        const packet = {
          cmd: "subscribe",
          subscriptions: subs,
          qos: 1,
          retain: false,
          dup: false,
          messageId
        };
        if (opts.properties) {
          packet.properties = opts.properties;
        }
        if (that.options.resubscribe) {
          debug("subscribe :: resubscribe true");
          const topics = [];
          subs.forEach(function(sub) {
            if (that.options.reconnectPeriod > 0) {
              const topic = { qos: sub.qos };
              if (version === 5) {
                topic.nl = sub.nl || false;
                topic.rap = sub.rap || false;
                topic.rh = sub.rh || 0;
                topic.properties = sub.properties;
              }
              that._resubscribeTopics[sub.topic] = topic;
              topics.push(sub.topic);
            }
          });
          that.messageIdToTopic[packet.messageId] = topics;
        }
        that.outgoing[packet.messageId] = {
          volatile: true,
          cb: function(err, packet2) {
            if (!err) {
              const granted = packet2.granted;
              for (let i = 0; i < granted.length; i += 1) {
                subs[i].qos = granted[i];
              }
            }
            callback(err, subs);
          }
        };
        debug("subscribe :: call _sendPacket");
        that._sendPacket(packet);
        return true;
      };
      if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !subscribeProc()) {
        this._storeProcessingQueue.push(
          {
            invoke: subscribeProc,
            callback
          }
        );
      }
      return this;
    };
    MqttClient.prototype.unsubscribe = function() {
      const that = this;
      const args = new Array(arguments.length);
      for (let i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }
      let topic = args.shift();
      let callback = args.pop() || nop;
      let opts = args.pop();
      if (typeof topic === "string") {
        topic = [topic];
      }
      if (typeof callback !== "function") {
        opts = callback;
        callback = nop;
      }
      const invalidTopic = validations.validateTopics(topic);
      if (invalidTopic !== null) {
        setImmediate(callback, new Error("Invalid topic " + invalidTopic));
        return this;
      }
      if (that._checkDisconnecting(callback)) {
        return this;
      }
      const unsubscribeProc = function() {
        const messageId = that._nextId();
        if (messageId === null) {
          debug("No messageId left");
          return false;
        }
        const packet = {
          cmd: "unsubscribe",
          qos: 1,
          messageId
        };
        if (typeof topic === "string") {
          packet.unsubscriptions = [topic];
        } else if (Array.isArray(topic)) {
          packet.unsubscriptions = topic;
        }
        if (that.options.resubscribe) {
          packet.unsubscriptions.forEach(function(topic2) {
            delete that._resubscribeTopics[topic2];
          });
        }
        if (typeof opts === "object" && opts.properties) {
          packet.properties = opts.properties;
        }
        that.outgoing[packet.messageId] = {
          volatile: true,
          cb: callback
        };
        debug("unsubscribe: call _sendPacket");
        that._sendPacket(packet);
        return true;
      };
      if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !unsubscribeProc()) {
        this._storeProcessingQueue.push(
          {
            invoke: unsubscribeProc,
            callback
          }
        );
      }
      return this;
    };
    MqttClient.prototype.end = function(force, opts, cb) {
      const that = this;
      debug("end :: (%s)", this.options.clientId);
      if (force == null || typeof force !== "boolean") {
        cb = opts || nop;
        opts = force;
        force = false;
        if (typeof opts !== "object") {
          cb = opts;
          opts = null;
          if (typeof cb !== "function") {
            cb = nop;
          }
        }
      }
      if (typeof opts !== "object") {
        cb = opts;
        opts = null;
      }
      debug("end :: cb? %s", !!cb);
      cb = cb || nop;
      function closeStores() {
        debug("end :: closeStores: closing incoming and outgoing stores");
        that.disconnected = true;
        that.incomingStore.close(function(e1) {
          that.outgoingStore.close(function(e2) {
            debug("end :: closeStores: emitting end");
            that.emit("end");
            if (cb) {
              const err = e1 || e2;
              debug("end :: closeStores: invoking callback with args");
              cb(err);
            }
          });
        });
        if (that._deferredReconnect) {
          that._deferredReconnect();
        }
      }
      function finish() {
        debug("end :: (%s) :: finish :: calling _cleanUp with force %s", that.options.clientId, force);
        that._cleanUp(force, () => {
          debug("end :: finish :: calling process.nextTick on closeStores");
          nextTick(closeStores.bind(that));
        }, opts);
      }
      if (this.disconnecting) {
        cb();
        return this;
      }
      this._clearReconnect();
      this.disconnecting = true;
      if (!force && Object.keys(this.outgoing).length > 0) {
        debug("end :: (%s) :: calling finish in 10ms once outgoing is empty", that.options.clientId);
        this.once("outgoingEmpty", setTimeout.bind(null, finish, 10));
      } else {
        debug("end :: (%s) :: immediately calling finish", that.options.clientId);
        finish();
      }
      return this;
    };
    MqttClient.prototype.removeOutgoingMessage = function(messageId) {
      const cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null;
      delete this.outgoing[messageId];
      this.outgoingStore.del({ messageId }, function() {
        cb(new Error("Message removed"));
      });
      return this;
    };
    MqttClient.prototype.reconnect = function(opts) {
      debug("client reconnect");
      const that = this;
      const f = function() {
        if (opts) {
          that.options.incomingStore = opts.incomingStore;
          that.options.outgoingStore = opts.outgoingStore;
        } else {
          that.options.incomingStore = null;
          that.options.outgoingStore = null;
        }
        that.incomingStore = that.options.incomingStore || new Store();
        that.outgoingStore = that.options.outgoingStore || new Store();
        that.disconnecting = false;
        that.disconnected = false;
        that._deferredReconnect = null;
        that._reconnect();
      };
      if (this.disconnecting && !this.disconnected) {
        this._deferredReconnect = f;
      } else {
        f();
      }
      return this;
    };
    MqttClient.prototype._reconnect = function() {
      debug("_reconnect: emitting reconnect to client");
      this.emit("reconnect");
      if (this.connected) {
        this.end(() => {
          this._setupStream();
        });
        debug("client already connected. disconnecting first.");
      } else {
        debug("_reconnect: calling _setupStream");
        this._setupStream();
      }
    };
    MqttClient.prototype._setupReconnect = function() {
      const that = this;
      if (!that.disconnecting && !that.reconnectTimer && that.options.reconnectPeriod > 0) {
        if (!this.reconnecting) {
          debug("_setupReconnect :: emit `offline` state");
          this.emit("offline");
          debug("_setupReconnect :: set `reconnecting` to `true`");
          this.reconnecting = true;
        }
        debug("_setupReconnect :: setting reconnectTimer for %d ms", that.options.reconnectPeriod);
        that.reconnectTimer = setInterval(function() {
          debug("reconnectTimer :: reconnect triggered!");
          that._reconnect();
        }, that.options.reconnectPeriod);
      } else {
        debug("_setupReconnect :: doing nothing...");
      }
    };
    MqttClient.prototype._clearReconnect = function() {
      debug("_clearReconnect : clearing reconnect timer");
      if (this.reconnectTimer) {
        clearInterval(this.reconnectTimer);
        this.reconnectTimer = null;
      }
    };
    MqttClient.prototype._cleanUp = function(forced, done) {
      const opts = arguments[2];
      if (done) {
        debug("_cleanUp :: done callback provided for on stream close");
        this.stream.on("close", done);
      }
      debug("_cleanUp :: forced? %s", forced);
      if (forced) {
        if (this.options.reconnectPeriod === 0 && this.options.clean) {
          flush(this.outgoing);
        }
        debug("_cleanUp :: (%s) :: destroying stream", this.options.clientId);
        this.stream.destroy();
      } else {
        const packet = xtend({ cmd: "disconnect" }, opts);
        debug("_cleanUp :: (%s) :: call _sendPacket with disconnect packet", this.options.clientId);
        this._sendPacket(
          packet,
          setImmediate.bind(
            null,
            this.stream.end.bind(this.stream)
          )
        );
      }
      if (!this.disconnecting) {
        debug("_cleanUp :: client not disconnecting. Clearing and resetting reconnect.");
        this._clearReconnect();
        this._setupReconnect();
      }
      if (this.pingTimer !== null) {
        debug("_cleanUp :: clearing pingTimer");
        this.pingTimer.clear();
        this.pingTimer = null;
      }
      if (done && !this.connected) {
        debug("_cleanUp :: (%s) :: removing stream `done` callback `close` listener", this.options.clientId);
        this.stream.removeListener("close", done);
        done();
      }
    };
    MqttClient.prototype._sendPacket = function(packet, cb, cbStorePut) {
      debug("_sendPacket :: (%s) ::  start", this.options.clientId);
      cbStorePut = cbStorePut || nop;
      cb = cb || nop;
      const err = applyTopicAlias(this, packet);
      if (err) {
        cb(err);
        return;
      }
      if (!this.connected) {
        if (packet.cmd === "auth") {
          this._shiftPingInterval();
          sendPacket(this, packet, cb);
          return;
        }
        debug("_sendPacket :: client not connected. Storing packet offline.");
        this._storePacket(packet, cb, cbStorePut);
        return;
      }
      this._shiftPingInterval();
      switch (packet.cmd) {
        case "publish":
          break;
        case "pubrel":
          storeAndSend(this, packet, cb, cbStorePut);
          return;
        default:
          sendPacket(this, packet, cb);
          return;
      }
      switch (packet.qos) {
        case 2:
        case 1:
          storeAndSend(this, packet, cb, cbStorePut);
          break;
        case 0:
        default:
          sendPacket(this, packet, cb);
          break;
      }
      debug("_sendPacket :: (%s) ::  end", this.options.clientId);
    };
    MqttClient.prototype._storePacket = function(packet, cb, cbStorePut) {
      debug("_storePacket :: packet: %o", packet);
      debug("_storePacket :: cb? %s", !!cb);
      cbStorePut = cbStorePut || nop;
      let storePacket = packet;
      if (storePacket.cmd === "publish") {
        storePacket = clone(packet);
        const err = removeTopicAliasAndRecoverTopicName(this, storePacket);
        if (err) {
          return cb && cb(err);
        }
      }
      if ((storePacket.qos || 0) === 0 && this.queueQoSZero || storePacket.cmd !== "publish") {
        this.queue.push({ packet: storePacket, cb });
      } else if (storePacket.qos > 0) {
        cb = this.outgoing[storePacket.messageId] ? this.outgoing[storePacket.messageId].cb : null;
        this.outgoingStore.put(storePacket, function(err) {
          if (err) {
            return cb && cb(err);
          }
          cbStorePut();
        });
      } else if (cb) {
        cb(new Error("No connection to broker"));
      }
    };
    MqttClient.prototype._setupPingTimer = function() {
      debug("_setupPingTimer :: keepalive %d (seconds)", this.options.keepalive);
      const that = this;
      if (!this.pingTimer && this.options.keepalive) {
        this.pingResp = true;
        this.pingTimer = reInterval(function() {
          that._checkPing();
        }, this.options.keepalive * 1e3);
      }
    };
    MqttClient.prototype._shiftPingInterval = function() {
      if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {
        this.pingTimer.reschedule(this.options.keepalive * 1e3);
      }
    };
    MqttClient.prototype._checkPing = function() {
      debug("_checkPing :: checking ping...");
      if (this.pingResp) {
        debug("_checkPing :: ping response received. Clearing flag and sending `pingreq`");
        this.pingResp = false;
        this._sendPacket({ cmd: "pingreq" });
      } else {
        debug("_checkPing :: calling _cleanUp with force true");
        this._cleanUp(true);
      }
    };
    MqttClient.prototype._handlePingresp = function() {
      this.pingResp = true;
    };
    MqttClient.prototype._handleConnack = function(packet) {
      debug("_handleConnack");
      const options = this.options;
      const version = options.protocolVersion;
      const rc = version === 5 ? packet.reasonCode : packet.returnCode;
      clearTimeout(this.connackTimer);
      delete this.topicAliasSend;
      if (packet.properties) {
        if (packet.properties.topicAliasMaximum) {
          if (packet.properties.topicAliasMaximum > 65535) {
            this.emit("error", new Error("topicAliasMaximum from broker is out of range"));
            return;
          }
          if (packet.properties.topicAliasMaximum > 0) {
            this.topicAliasSend = new TopicAliasSend(packet.properties.topicAliasMaximum);
          }
        }
        if (packet.properties.serverKeepAlive && options.keepalive) {
          options.keepalive = packet.properties.serverKeepAlive;
          this._shiftPingInterval();
        }
        if (packet.properties.maximumPacketSize) {
          if (!options.properties) {
            options.properties = {};
          }
          options.properties.maximumPacketSize = packet.properties.maximumPacketSize;
        }
      }
      if (rc === 0) {
        this.reconnecting = false;
        this._onConnect(packet);
      } else if (rc > 0) {
        const err = new Error("Connection refused: " + errors[rc]);
        err.code = rc;
        this.emit("error", err);
      }
    };
    MqttClient.prototype._handleAuth = function(packet) {
      const options = this.options;
      const version = options.protocolVersion;
      const rc = version === 5 ? packet.reasonCode : packet.returnCode;
      if (version !== 5) {
        const err = new Error("Protocol error: Auth packets are only supported in MQTT 5. Your version:" + version);
        err.code = rc;
        this.emit("error", err);
        return;
      }
      const that = this;
      this.handleAuth(packet, function(err, packet2) {
        if (err) {
          that.emit("error", err);
          return;
        }
        if (rc === 24) {
          that.reconnecting = false;
          that._sendPacket(packet2);
        } else {
          const error = new Error("Connection refused: " + errors[rc]);
          err.code = rc;
          that.emit("error", error);
        }
      });
    };
    MqttClient.prototype.handleAuth = function(packet, callback) {
      callback();
    };
    MqttClient.prototype._handlePublish = function(packet, done) {
      debug("_handlePublish: packet %o", packet);
      done = typeof done !== "undefined" ? done : nop;
      let topic = packet.topic.toString();
      const message = packet.payload;
      const qos = packet.qos;
      const messageId = packet.messageId;
      const that = this;
      const options = this.options;
      const validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153];
      if (this.options.protocolVersion === 5) {
        let alias;
        if (packet.properties) {
          alias = packet.properties.topicAlias;
        }
        if (typeof alias !== "undefined") {
          if (topic.length === 0) {
            if (alias > 0 && alias <= 65535) {
              const gotTopic = this.topicAliasRecv.getTopicByAlias(alias);
              if (gotTopic) {
                topic = gotTopic;
                debug("_handlePublish :: topic complemented by alias. topic: %s - alias: %d", topic, alias);
              } else {
                debug("_handlePublish :: unregistered topic alias. alias: %d", alias);
                this.emit("error", new Error("Received unregistered Topic Alias"));
                return;
              }
            } else {
              debug("_handlePublish :: topic alias out of range. alias: %d", alias);
              this.emit("error", new Error("Received Topic Alias is out of range"));
              return;
            }
          } else {
            if (this.topicAliasRecv.put(topic, alias)) {
              debug("_handlePublish :: registered topic: %s - alias: %d", topic, alias);
            } else {
              debug("_handlePublish :: topic alias out of range. alias: %d", alias);
              this.emit("error", new Error("Received Topic Alias is out of range"));
              return;
            }
          }
        }
      }
      debug("_handlePublish: qos %d", qos);
      switch (qos) {
        case 2: {
          options.customHandleAcks(topic, message, packet, function(error, code) {
            if (!(error instanceof Error)) {
              code = error;
              error = null;
            }
            if (error) {
              return that.emit("error", error);
            }
            if (validReasonCodes.indexOf(code) === -1) {
              return that.emit("error", new Error("Wrong reason code for pubrec"));
            }
            if (code) {
              that._sendPacket({ cmd: "pubrec", messageId, reasonCode: code }, done);
            } else {
              that.incomingStore.put(packet, function() {
                that._sendPacket({ cmd: "pubrec", messageId }, done);
              });
            }
          });
          break;
        }
        case 1: {
          options.customHandleAcks(topic, message, packet, function(error, code) {
            if (!(error instanceof Error)) {
              code = error;
              error = null;
            }
            if (error) {
              return that.emit("error", error);
            }
            if (validReasonCodes.indexOf(code) === -1) {
              return that.emit("error", new Error("Wrong reason code for puback"));
            }
            if (!code) {
              that.emit("message", topic, message, packet);
            }
            that.handleMessage(packet, function(err) {
              if (err) {
                return done && done(err);
              }
              that._sendPacket({ cmd: "puback", messageId, reasonCode: code }, done);
            });
          });
          break;
        }
        case 0:
          this.emit("message", topic, message, packet);
          this.handleMessage(packet, done);
          break;
        default:
          debug("_handlePublish: unknown QoS. Doing nothing.");
          break;
      }
    };
    MqttClient.prototype.handleMessage = function(packet, callback) {
      callback();
    };
    MqttClient.prototype._handleAck = function(packet) {
      const messageId = packet.messageId;
      const type = packet.cmd;
      let response = null;
      const cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null;
      const that = this;
      let err;
      if (!cb) {
        debug("_handleAck :: Server sent an ack in error. Ignoring.");
        return;
      }
      debug("_handleAck :: packet type", type);
      switch (type) {
        case "pubcomp":
        case "puback": {
          const pubackRC = packet.reasonCode;
          if (pubackRC && pubackRC > 0 && pubackRC !== 16) {
            err = new Error("Publish error: " + errors[pubackRC]);
            err.code = pubackRC;
            cb(err, packet);
          }
          delete this.outgoing[messageId];
          this.outgoingStore.del(packet, cb);
          this.messageIdProvider.deallocate(messageId);
          this._invokeStoreProcessingQueue();
          break;
        }
        case "pubrec": {
          response = {
            cmd: "pubrel",
            qos: 2,
            messageId
          };
          const pubrecRC = packet.reasonCode;
          if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {
            err = new Error("Publish error: " + errors[pubrecRC]);
            err.code = pubrecRC;
            cb(err, packet);
          } else {
            this._sendPacket(response);
          }
          break;
        }
        case "suback": {
          delete this.outgoing[messageId];
          this.messageIdProvider.deallocate(messageId);
          for (let grantedI = 0; grantedI < packet.granted.length; grantedI++) {
            if ((packet.granted[grantedI] & 128) !== 0) {
              const topics = this.messageIdToTopic[messageId];
              if (topics) {
                topics.forEach(function(topic) {
                  delete that._resubscribeTopics[topic];
                });
              }
            }
          }
          this._invokeStoreProcessingQueue();
          cb(null, packet);
          break;
        }
        case "unsuback": {
          delete this.outgoing[messageId];
          this.messageIdProvider.deallocate(messageId);
          this._invokeStoreProcessingQueue();
          cb(null);
          break;
        }
        default:
          that.emit("error", new Error("unrecognized packet type"));
      }
      if (this.disconnecting && Object.keys(this.outgoing).length === 0) {
        this.emit("outgoingEmpty");
      }
    };
    MqttClient.prototype._handlePubrel = function(packet, callback) {
      debug("handling pubrel packet");
      callback = typeof callback !== "undefined" ? callback : nop;
      const messageId = packet.messageId;
      const that = this;
      const comp = { cmd: "pubcomp", messageId };
      that.incomingStore.get(packet, function(err, pub) {
        if (!err) {
          that.emit("message", pub.topic, pub.payload, pub);
          that.handleMessage(pub, function(err2) {
            if (err2) {
              return callback(err2);
            }
            that.incomingStore.del(pub, nop);
            that._sendPacket(comp, callback);
          });
        } else {
          that._sendPacket(comp, callback);
        }
      });
    };
    MqttClient.prototype._handleDisconnect = function(packet) {
      this.emit("disconnect", packet);
    };
    MqttClient.prototype._nextId = function() {
      return this.messageIdProvider.allocate();
    };
    MqttClient.prototype.getLastMessageId = function() {
      return this.messageIdProvider.getLastAllocated();
    };
    MqttClient.prototype._resubscribe = function() {
      debug("_resubscribe");
      const _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics);
      if (!this._firstConnection && (this.options.clean || this.options.protocolVersion === 5 && !this.connackPacket.sessionPresent) && _resubscribeTopicsKeys.length > 0) {
        if (this.options.resubscribe) {
          if (this.options.protocolVersion === 5) {
            debug("_resubscribe: protocolVersion 5");
            for (let topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {
              const resubscribeTopic = {};
              resubscribeTopic[_resubscribeTopicsKeys[topicI]] = this._resubscribeTopics[_resubscribeTopicsKeys[topicI]];
              resubscribeTopic.resubscribe = true;
              this.subscribe(resubscribeTopic, { properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties });
            }
          } else {
            this._resubscribeTopics.resubscribe = true;
            this.subscribe(this._resubscribeTopics);
          }
        } else {
          this._resubscribeTopics = {};
        }
      }
      this._firstConnection = false;
    };
    MqttClient.prototype._onConnect = function(packet) {
      if (this.disconnected) {
        this.emit("connect", packet);
        return;
      }
      const that = this;
      this.connackPacket = packet;
      this.messageIdProvider.clear();
      this._setupPingTimer();
      this.connected = true;
      function startStreamProcess() {
        let outStore = that.outgoingStore.createStream();
        function clearStoreProcessing() {
          that._storeProcessing = false;
          that._packetIdsDuringStoreProcessing = {};
        }
        that.once("close", remove);
        outStore.on("error", function(err) {
          clearStoreProcessing();
          that._flushStoreProcessingQueue();
          that.removeListener("close", remove);
          that.emit("error", err);
        });
        function remove() {
          outStore.destroy();
          outStore = null;
          that._flushStoreProcessingQueue();
          clearStoreProcessing();
        }
        function storeDeliver() {
          if (!outStore) {
            return;
          }
          that._storeProcessing = true;
          const packet2 = outStore.read(1);
          let cb;
          if (!packet2) {
            outStore.once("readable", storeDeliver);
            return;
          }
          if (that._packetIdsDuringStoreProcessing[packet2.messageId]) {
            storeDeliver();
            return;
          }
          if (!that.disconnecting && !that.reconnectTimer) {
            cb = that.outgoing[packet2.messageId] ? that.outgoing[packet2.messageId].cb : null;
            that.outgoing[packet2.messageId] = {
              volatile: false,
              cb: function(err, status) {
                if (cb) {
                  cb(err, status);
                }
                storeDeliver();
              }
            };
            that._packetIdsDuringStoreProcessing[packet2.messageId] = true;
            if (that.messageIdProvider.register(packet2.messageId)) {
              that._sendPacket(packet2);
            } else {
              debug("messageId: %d has already used.", packet2.messageId);
            }
          } else if (outStore.destroy) {
            outStore.destroy();
          }
        }
        outStore.on("end", function() {
          let allProcessed = true;
          for (const id in that._packetIdsDuringStoreProcessing) {
            if (!that._packetIdsDuringStoreProcessing[id]) {
              allProcessed = false;
              break;
            }
          }
          if (allProcessed) {
            clearStoreProcessing();
            that.removeListener("close", remove);
            that._invokeAllStoreProcessingQueue();
            that.emit("connect", packet);
          } else {
            startStreamProcess();
          }
        });
        storeDeliver();
      }
      startStreamProcess();
    };
    MqttClient.prototype._invokeStoreProcessingQueue = function() {
      if (this._storeProcessingQueue.length > 0) {
        const f = this._storeProcessingQueue[0];
        if (f && f.invoke()) {
          this._storeProcessingQueue.shift();
          return true;
        }
      }
      return false;
    };
    MqttClient.prototype._invokeAllStoreProcessingQueue = function() {
      while (this._invokeStoreProcessingQueue()) {
      }
    };
    MqttClient.prototype._flushStoreProcessingQueue = function() {
      for (const f of this._storeProcessingQueue) {
        if (f.cbStorePut)
          f.cbStorePut(new Error("Connection closed"));
        if (f.callback)
          f.callback(new Error("Connection closed"));
      }
      this._storeProcessingQueue.splice(0);
    };
    module.exports = MqttClient;
  }
});

// node_modules/node-stdlib-browser/node_modules/punycode/punycode.js
var require_punycode = __commonJS({
  "node_modules/node-stdlib-browser/node_modules/punycode/punycode.js"(exports, module) {
    init_shim();
    (function(root) {
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = typeof module == "object" && module && !module.nodeType && module;
      var freeGlobal = typeof _global == "object" && _global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root = freeGlobal;
      }
      var punycode2, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
      function error(type) {
        throw new RangeError(errors[type]);
      }
      function map(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [], counter = 0, length = string.length, value, extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map(array, function(value) {
          var output = "";
          if (value > 65535) {
            value -= 65536;
            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output += stringFromCharCode(value);
          return output;
        }).join("");
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode3(input) {
        var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          for (oldi = i, w = 1, k = base; ; k += base) {
            if (index >= inputLength) {
              error("invalid-input");
            }
            digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error("overflow");
            }
            i += digit * w;
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error("overflow");
            }
            w *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return ucs2encode(output);
      }
      function encode3(input) {
        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n = initialN;
        delta = 0;
        bias = initialBias;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m = maxInt, j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < n && ++delta > maxInt) {
              error("overflow");
            }
            if (currentValue == n) {
              for (q = delta, k = base; ; k += base) {
                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) {
                  break;
                }
                qMinusT = q - t;
                baseMinusT = base - t;
                output.push(
                  stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                );
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      }
      function toUnicode(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode3(string.slice(4).toLowerCase()) : string;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode3(string) : string;
        });
      }
      punycode2 = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "1.4.1",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode3,
        "encode": encode3,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define("punycode", function() {
          return punycode2;
        });
      } else if (freeExports && freeModule) {
        if (module.exports == freeExports) {
          freeModule.exports = punycode2;
        } else {
          for (key in punycode2) {
            punycode2.hasOwnProperty(key) && (freeExports[key] = punycode2[key]);
          }
        }
      } else {
        root.punycode = punycode2;
      }
    })(exports);
  }
});

// node_modules/querystring-es3/decode.js
var require_decode = __commonJS({
  "node_modules/querystring-es3/decode.js"(exports, module) {
    "use strict";
    init_shim();
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    module.exports = function(qs, sep, eq, options) {
      sep = sep || "&";
      eq = eq || "=";
      var obj = {};
      if (typeof qs !== "string" || qs.length === 0) {
        return obj;
      }
      var regexp = /\+/g;
      qs = qs.split(sep);
      var maxKeys = 1e3;
      if (options && typeof options.maxKeys === "number") {
        maxKeys = options.maxKeys;
      }
      var len = qs.length;
      if (maxKeys > 0 && len > maxKeys) {
        len = maxKeys;
      }
      for (var i = 0; i < len; ++i) {
        var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
        if (idx >= 0) {
          kstr = x.substr(0, idx);
          vstr = x.substr(idx + 1);
        } else {
          kstr = x;
          vstr = "";
        }
        k = decodeURIComponent(kstr);
        v = decodeURIComponent(vstr);
        if (!hasOwnProperty(obj, k)) {
          obj[k] = v;
        } else if (isArray(obj[k])) {
          obj[k].push(v);
        } else {
          obj[k] = [obj[k], v];
        }
      }
      return obj;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// node_modules/querystring-es3/encode.js
var require_encode = __commonJS({
  "node_modules/querystring-es3/encode.js"(exports, module) {
    "use strict";
    init_shim();
    var stringifyPrimitive = function(v) {
      switch (typeof v) {
        case "string":
          return v;
        case "boolean":
          return v ? "true" : "false";
        case "number":
          return isFinite(v) ? v : "";
        default:
          return "";
      }
    };
    module.exports = function(obj, sep, eq, name) {
      sep = sep || "&";
      eq = eq || "=";
      if (obj === null) {
        obj = void 0;
      }
      if (typeof obj === "object") {
        return map(objectKeys(obj), function(k) {
          var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
          if (isArray(obj[k])) {
            return map(obj[k], function(v) {
              return ks + encodeURIComponent(stringifyPrimitive(v));
            }).join(sep);
          } else {
            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
          }
        }).join(sep);
      }
      if (!name)
        return "";
      return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
    function map(xs, f) {
      if (xs.map)
        return xs.map(f);
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        res.push(f(xs[i], i));
      }
      return res;
    }
    var objectKeys = Object.keys || function(obj) {
      var res = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key))
          res.push(key);
      }
      return res;
    };
  }
});

// node_modules/querystring-es3/index.js
var require_querystring_es3 = __commonJS({
  "node_modules/querystring-es3/index.js"(exports) {
    "use strict";
    init_shim();
    exports.decode = exports.parse = require_decode();
    exports.encode = exports.stringify = require_encode();
  }
});

// node_modules/node-stdlib-browser/esm/proxy/querystring.js
function qsEscape(string) {
  return encodeURIComponent(string);
}
function qsUnescape(string) {
  return decodeURIComponent(string);
}
var import_querystring_es3, import_querystring_es32, api;
var init_querystring = __esm({
  "node_modules/node-stdlib-browser/esm/proxy/querystring.js"() {
    init_shim();
    import_querystring_es3 = __toESM(require_querystring_es3());
    import_querystring_es32 = __toESM(require_querystring_es3());
    api = {
      decode: import_querystring_es3.decode,
      encode: import_querystring_es3.encode,
      parse: import_querystring_es3.parse,
      stringify: import_querystring_es3.stringify,
      escape: qsEscape,
      unescape: qsUnescape
    };
  }
});

// node_modules/node-stdlib-browser/esm/proxy/url.js
var url_exports = {};
__export(url_exports, {
  URL: () => URL2,
  URLSearchParams: () => URLSearchParams,
  Url: () => UrlImport,
  default: () => api2,
  domainToASCII: () => domainToASCII,
  domainToUnicode: () => domainToUnicode,
  fileURLToPath: () => fileURLToPath,
  format: () => formatImportWithOverloads,
  parse: () => parseImport,
  pathToFileURL: () => pathToFileURL,
  resolve: () => resolveImport,
  resolveObject: () => resolveObject
});
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}
function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url)
    return url;
  var u = new Url();
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}
function urlFormat(obj) {
  if (util.isString(obj))
    obj = urlParse(obj);
  if (!(obj instanceof Url))
    return Url.prototype.format.call(obj);
  return obj.format();
}
function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}
function urlResolveObject(source, relative) {
  if (!source)
    return relative;
  return urlParse(source, false, true).resolveObject(relative);
}
function normalizeArray(parts, allowAboveRoot) {
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === ".") {
      parts.splice(i, 1);
    } else if (last === "..") {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift("..");
    }
  }
  return parts;
}
function resolve() {
  var resolvedPath = "", resolvedAbsolute = false;
  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = i >= 0 ? arguments[i] : "/";
    if (typeof path !== "string") {
      throw new TypeError("Arguments to path.resolve must be strings");
    } else if (!path) {
      continue;
    }
    resolvedPath = path + "/" + resolvedPath;
    resolvedAbsolute = path.charAt(0) === "/";
  }
  resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function(p) {
    return !!p;
  }), !resolvedAbsolute).join("/");
  return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
}
function filter(xs, f) {
  if (xs.filter)
    return xs.filter(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    if (f(xs[i], i, xs))
      res.push(xs[i]);
  }
  return res;
}
function isURLInstance(instance) {
  var resolved = (
    /** @type {URL|null} */
    instance != null ? instance : null
  );
  return Boolean(resolved !== null && (resolved == null ? void 0 : resolved.href) && (resolved == null ? void 0 : resolved.origin));
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    throw new TypeError('File URL host must be "localhost" or empty on browser');
  }
  var pathname = url.pathname;
  for (var n = 0; n < pathname.length; n++) {
    if (pathname[n] === "%") {
      var third = pathname.codePointAt(n + 2) | 32;
      if (pathname[n + 1] === "2" && third === 102) {
        throw new TypeError("File URL path must not include encoded / characters");
      }
    }
  }
  return decodeURIComponent(pathname);
}
function encodePathChars(filepath) {
  if (filepath.includes("%")) {
    filepath = filepath.replace(percentRegEx, "%25");
  }
  if (filepath.includes("\\")) {
    filepath = filepath.replace(backslashRegEx, "%5C");
  }
  if (filepath.includes("\n")) {
    filepath = filepath.replace(newlineRegEx, "%0A");
  }
  if (filepath.includes("\r")) {
    filepath = filepath.replace(carriageReturnRegEx, "%0D");
  }
  if (filepath.includes("	")) {
    filepath = filepath.replace(tabRegEx, "%09");
  }
  return filepath;
}
var import_punycode, util$1, punycode, util, parse3, resolve$1, resolveObject, format, Url_1, protocolPattern, portPattern, simplePathPattern, delims, unwise, autoEscape, nonHostChars, hostEndingChars, hostnameMaxLen, hostnamePartPattern, hostnamePartStart, unsafeProtocol, hostlessProtocol, slashedProtocol, querystring, _globalThis, formatImport, parseImport, resolveImport, UrlImport, URL2, URLSearchParams, percentRegEx, backslashRegEx, newlineRegEx, carriageReturnRegEx, tabRegEx, CHAR_FORWARD_SLASH, domainToASCII, domainToUnicode, pathToFileURL, fileURLToPath, formatImportWithOverloads, api2;
var init_url = __esm({
  "node_modules/node-stdlib-browser/esm/proxy/url.js"() {
    init_shim();
    import_punycode = __toESM(require_punycode());
    init_querystring();
    util$1 = {
      isString: function(arg) {
        return typeof arg === "string";
      },
      isObject: function(arg) {
        return typeof arg === "object" && arg !== null;
      },
      isNull: function(arg) {
        return arg === null;
      },
      isNullOrUndefined: function(arg) {
        return arg == null;
      }
    };
    punycode = import_punycode.default;
    util = util$1;
    parse3 = urlParse;
    resolve$1 = urlResolve;
    resolveObject = urlResolveObject;
    format = urlFormat;
    Url_1 = Url;
    protocolPattern = /^([a-z0-9.+-]+:)/i;
    portPattern = /:[0-9]*$/;
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
    unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
    autoEscape = ["'"].concat(unwise);
    nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
    hostEndingChars = ["/", "?", "#"];
    hostnameMaxLen = 255;
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    unsafeProtocol = {
      "javascript": true,
      "javascript:": true
    };
    hostlessProtocol = {
      "javascript": true,
      "javascript:": true
    };
    slashedProtocol = {
      "http": true,
      "https": true,
      "ftp": true,
      "gopher": true,
      "file": true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    querystring = api;
    Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
      if (!util.isString(url)) {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
      }
      var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
      uSplit[0] = uSplit[0].replace(slashRegex, "/");
      url = uSplit.join(splitter);
      var rest = url;
      rest = rest.trim();
      if (!slashesDenoteHost && url.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.path = rest;
          this.href = rest;
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
            if (parseQueryString) {
              this.query = querystring.parse(this.search.substr(1));
            } else {
              this.query = this.search.substr(1);
            }
          } else if (parseQueryString) {
            this.search = "";
            this.query = {};
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (var i = 0; i < hostEndingChars.length; i++) {
          var hec = rest.indexOf(hostEndingChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = decodeURIComponent(auth);
        }
        hostEnd = -1;
        for (var i = 0; i < nonHostChars.length; i++) {
          var hec = rest.indexOf(nonHostChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }
        if (hostEnd === -1)
          hostEnd = rest.length;
        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost();
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (var i = 0, l = hostparts.length; i < l; i++) {
            var part = hostparts[i];
            if (!part)
              continue;
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i);
                var notHost = hostparts.slice(i + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = "/" + notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        } else {
          this.hostname = this.hostname.toLowerCase();
        }
        if (!ipv6Hostname) {
          this.hostname = punycode.toASCII(this.hostname);
        }
        var p = this.port ? ":" + this.port : "";
        var h = this.hostname || "";
        this.host = h + p;
        this.href += this.host;
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
          if (rest[0] !== "/") {
            rest = "/" + rest;
          }
        }
      }
      if (!unsafeProtocol[lowerProto]) {
        for (var i = 0, l = autoEscape.length; i < l; i++) {
          var ae = autoEscape[i];
          if (rest.indexOf(ae) === -1)
            continue;
          var esc = encodeURIComponent(ae);
          if (esc === ae) {
            esc = escape(ae);
          }
          rest = rest.split(ae).join(esc);
        }
      }
      var hash = rest.indexOf("#");
      if (hash !== -1) {
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);
        if (parseQueryString) {
          this.query = querystring.parse(this.query);
        }
        rest = rest.slice(0, qm);
      } else if (parseQueryString) {
        this.search = "";
        this.query = {};
      }
      if (rest)
        this.pathname = rest;
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "/";
      }
      if (this.pathname || this.search) {
        var p = this.pathname || "";
        var s = this.search || "";
        this.path = p + s;
      }
      this.href = this.format();
      return this;
    };
    Url.prototype.format = function() {
      var auth = this.auth || "";
      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ":");
        auth += "@";
      }
      var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
      if (this.host) {
        host = auth + this.host;
      } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
        if (this.port) {
          host += ":" + this.port;
        }
      }
      if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
        query = querystring.stringify(this.query);
      }
      var search = this.search || query && "?" + query || "";
      if (protocol && protocol.substr(-1) !== ":")
        protocol += ":";
      if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = "//" + (host || "");
        if (pathname && pathname.charAt(0) !== "/")
          pathname = "/" + pathname;
      } else if (!host) {
        host = "";
      }
      if (hash && hash.charAt(0) !== "#")
        hash = "#" + hash;
      if (search && search.charAt(0) !== "?")
        search = "?" + search;
      pathname = pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
      });
      search = search.replace("#", "%23");
      return protocol + host + pathname + search + hash;
    };
    Url.prototype.resolve = function(relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };
    Url.prototype.resolveObject = function(relative) {
      if (util.isString(relative)) {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
      }
      var result = new Url();
      var tkeys = Object.keys(this);
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
      }
      result.hash = relative.hash;
      if (relative.href === "") {
        result.href = result.format();
        return result;
      }
      if (relative.slashes && !relative.protocol) {
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk];
          if (rkey !== "protocol")
            result[rkey] = relative[rkey];
        }
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
          result.path = result.pathname = "/";
        }
        result.href = result.format();
        return result;
      }
      if (relative.protocol && relative.protocol !== result.protocol) {
        if (!slashedProtocol[relative.protocol]) {
          var keys = Object.keys(relative);
          for (var v = 0; v < keys.length; v++) {
            var k = keys[v];
            result[k] = relative[k];
          }
          result.href = result.format();
          return result;
        }
        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          var relPath = (relative.pathname || "").split("/");
          while (relPath.length && !(relative.host = relPath.shift()))
            ;
          if (!relative.host)
            relative.host = "";
          if (!relative.hostname)
            relative.hostname = "";
          if (relPath[0] !== "")
            relPath.unshift("");
          if (relPath.length < 2)
            relPath.unshift("");
          result.pathname = relPath.join("/");
        } else {
          result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || "";
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        if (result.pathname || result.search) {
          var p = result.pathname || "";
          var s = result.search || "";
          result.path = p + s;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }
      var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
      if (psychotic) {
        result.hostname = "";
        result.port = null;
        if (result.host) {
          if (srcPath[0] === "")
            srcPath[0] = result.host;
          else
            srcPath.unshift(result.host);
        }
        result.host = "";
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === "")
              relPath[0] = relative.host;
            else
              relPath.unshift(relative.host);
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
      }
      if (isRelAbs) {
        result.host = relative.host || relative.host === "" ? relative.host : result.host;
        result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
      } else if (relPath.length) {
        if (!srcPath)
          srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else if (!util.isNullOrUndefined(relative.search)) {
        if (psychotic) {
          result.hostname = result.host = srcPath.shift();
          var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }
        result.search = relative.search;
        result.query = relative.query;
        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.href = result.format();
        return result;
      }
      if (!srcPath.length) {
        result.pathname = null;
        if (result.search) {
          result.path = "/" + result.search;
        } else {
          result.path = null;
        }
        result.href = result.format();
        return result;
      }
      var last = srcPath.slice(-1)[0];
      var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
      var up = 0;
      for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];
        if (last === ".") {
          srcPath.splice(i, 1);
        } else if (last === "..") {
          srcPath.splice(i, 1);
          up++;
        } else if (up) {
          srcPath.splice(i, 1);
          up--;
        }
      }
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift("..");
        }
      }
      if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
        srcPath.unshift("");
      }
      if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
        srcPath.push("");
      }
      var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
      if (psychotic) {
        result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
      mustEndAbs = mustEndAbs || result.host && srcPath.length;
      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift("");
      }
      if (!srcPath.length) {
        result.pathname = null;
        result.path = null;
      } else {
        result.pathname = srcPath.join("/");
      }
      if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      }
      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    };
    Url.prototype.parseHost = function() {
      var host = this.host;
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host)
        this.hostname = host;
    };
    _globalThis = function(Object2) {
      function get() {
        var _global3 = this || self;
        delete Object2.prototype.__magic__;
        return _global3;
      }
      if (typeof globalThis === "object") {
        return globalThis;
      }
      if (this) {
        return get();
      } else {
        Object2.defineProperty(Object2.prototype, "__magic__", {
          configurable: true,
          get
        });
        var _global2 = __magic__;
        return _global2;
      }
    }(Object);
    formatImport = /** @type {formatImport}*/
    format;
    parseImport = /** @type {parseImport}*/
    parse3;
    resolveImport = /** @type {resolveImport}*/
    resolve$1;
    UrlImport = /** @type {UrlImport}*/
    Url_1;
    URL2 = _globalThis.URL;
    URLSearchParams = _globalThis.URLSearchParams;
    percentRegEx = /%/g;
    backslashRegEx = /\\/g;
    newlineRegEx = /\n/g;
    carriageReturnRegEx = /\r/g;
    tabRegEx = /\t/g;
    CHAR_FORWARD_SLASH = 47;
    domainToASCII = /**
     * @type {domainToASCII}
     */
    function domainToASCII2(domain) {
      if (typeof domain === "undefined") {
        throw new TypeError('The "domain" argument must be specified');
      }
      return new URL2("http://" + domain).hostname;
    };
    domainToUnicode = /**
     * @type {domainToUnicode}
     */
    function domainToUnicode2(domain) {
      if (typeof domain === "undefined") {
        throw new TypeError('The "domain" argument must be specified');
      }
      return new URL2("http://" + domain).hostname;
    };
    pathToFileURL = /**
     * @type {(url: string) => URL}
     */
    function pathToFileURL2(filepath) {
      var outURL = new URL2("file://");
      var resolved = resolve(filepath);
      var filePathLast = filepath.charCodeAt(filepath.length - 1);
      if (filePathLast === CHAR_FORWARD_SLASH && resolved[resolved.length - 1] !== "/") {
        resolved += "/";
      }
      outURL.pathname = encodePathChars(resolved);
      return outURL;
    };
    fileURLToPath = /**
     * @type {fileURLToPath & ((path: string | URL) => string)}
     */
    function fileURLToPath2(path) {
      if (!isURLInstance(path) && typeof path !== "string") {
        throw new TypeError('The "path" argument must be of type string or an instance of URL. Received type ' + typeof path + " (" + path + ")");
      }
      var resolved = new URL2(path);
      if (resolved.protocol !== "file:") {
        throw new TypeError("The URL must be of scheme file");
      }
      return getPathFromURLPosix(resolved);
    };
    formatImportWithOverloads = /**
     * @type {(
     *   ((urlObject: URL, options?: URLFormatOptions) => string) &
     *   ((urlObject: UrlObject | string, options?: never) => string)
     * )}
     */
    function formatImportWithOverloads2(urlObject, options) {
      var _options$auth, _options$fragment, _options$search;
      if (options === void 0) {
        options = {};
      }
      if (!(urlObject instanceof URL2)) {
        return formatImport(urlObject);
      }
      if (typeof options !== "object" || options === null) {
        throw new TypeError('The "options" argument must be of type object.');
      }
      var auth = (_options$auth = options.auth) != null ? _options$auth : true;
      var fragment = (_options$fragment = options.fragment) != null ? _options$fragment : true;
      var search = (_options$search = options.search) != null ? _options$search : true;
      var parsed = new URL2(urlObject.toString());
      if (!auth) {
        parsed.username = "";
        parsed.password = "";
      }
      if (!fragment) {
        parsed.hash = "";
      }
      if (!search) {
        parsed.search = "";
      }
      return parsed.toString();
    };
    api2 = {
      format: formatImportWithOverloads,
      parse: parseImport,
      resolve: resolveImport,
      resolveObject,
      Url: UrlImport,
      URL: URL2,
      URLSearchParams,
      domainToASCII,
      domainToUnicode,
      pathToFileURL,
      fileURLToPath
    };
  }
});

// node_modules/node-stdlib-browser/esm/mock/empty.js
var empty_exports = {};
__export(empty_exports, {
  default: () => empty
});
var empty;
var init_empty = __esm({
  "node_modules/node-stdlib-browser/esm/mock/empty.js"() {
    init_shim();
    empty = null;
  }
});

// node_modules/mqtt/lib/connect/tcp.js
var require_tcp = __commonJS({
  "node_modules/mqtt/lib/connect/tcp.js"(exports, module) {
    "use strict";
    init_shim();
    var net = (init_empty(), __toCommonJS(empty_exports));
    var debug = require_browser2()("mqttjs:tcp");
    function streamBuilder(client, opts) {
      opts.port = opts.port || 1883;
      opts.hostname = opts.hostname || opts.host || "localhost";
      const port = opts.port;
      const host = opts.hostname;
      debug("port %d and host %s", port, host);
      return net.createConnection(port, host);
    }
    module.exports = streamBuilder;
  }
});

// node_modules/mqtt/lib/connect/tls.js
var require_tls = __commonJS({
  "node_modules/mqtt/lib/connect/tls.js"(exports, module) {
    "use strict";
    init_shim();
    var tls = (init_empty(), __toCommonJS(empty_exports));
    var net = (init_empty(), __toCommonJS(empty_exports));
    var debug = require_browser2()("mqttjs:tls");
    function buildBuilder(mqttClient, opts) {
      opts.port = opts.port || 8883;
      opts.host = opts.hostname || opts.host || "localhost";
      if (net.isIP(opts.host) === 0) {
        opts.servername = opts.host;
      }
      opts.rejectUnauthorized = opts.rejectUnauthorized !== false;
      delete opts.path;
      debug("port %d host %s rejectUnauthorized %b", opts.port, opts.host, opts.rejectUnauthorized);
      const connection = tls.connect(opts);
      connection.on("secureConnect", function() {
        if (opts.rejectUnauthorized && !connection.authorized) {
          connection.emit("error", new Error("TLS not authorized"));
        } else {
          connection.removeListener("error", handleTLSerrors);
        }
      });
      function handleTLSerrors(err) {
        if (opts.rejectUnauthorized) {
          mqttClient.emit("error", err);
        }
        connection.end();
      }
      connection.on("error", handleTLSerrors);
      return connection;
    }
    module.exports = buildBuilder;
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports, module) {
    init_shim();
    module.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports, module) {
    init_shim();
    var wrappy = require_wrappy();
    module.exports = wrappy(once);
    module.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// node_modules/end-of-stream/index.js
var require_end_of_stream2 = __commonJS({
  "node_modules/end-of-stream/index.js"(exports, module) {
    init_shim();
    var once = require_once();
    var noop = function() {
    };
    var isRequest = function(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    };
    var isChildProcess = function(stream) {
      return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
    };
    var eos = function(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var ws = stream._writableState;
      var rs = stream._readableState;
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var cancelled = false;
      var onlegacyfinish = function() {
        if (!stream.writable)
          onfinish();
      };
      var onfinish = function() {
        writable = false;
        if (!readable)
          callback.call(stream);
      };
      var onend = function() {
        readable = false;
        if (!writable)
          callback.call(stream);
      };
      var onexit = function(exitCode) {
        callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
      };
      var onerror = function(err) {
        callback.call(stream, err);
      };
      var onclose = function() {
        import_process.default.nextTick(onclosenexttick);
      };
      var onclosenexttick = function() {
        if (cancelled)
          return;
        if (readable && !(rs && (rs.ended && !rs.destroyed)))
          return callback.call(stream, new Error("premature close"));
        if (writable && !(ws && (ws.ended && !ws.destroyed)))
          return callback.call(stream, new Error("premature close"));
      };
      var onrequest = function() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !ws) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (isChildProcess(stream))
        stream.on("exit", onexit);
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        cancelled = true;
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("exit", onexit);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    };
    module.exports = eos;
  }
});

// node_modules/stream-shift/index.js
var require_stream_shift = __commonJS({
  "node_modules/stream-shift/index.js"(exports, module) {
    init_shim();
    module.exports = shift;
    function shift(stream) {
      var rs = stream._readableState;
      if (!rs)
        return null;
      return rs.objectMode || typeof stream._duplexState === "number" ? stream.read() : stream.read(getStateLength(rs));
    }
    function getStateLength(state) {
      if (state.buffer.length) {
        if (state.buffer.head) {
          return state.buffer.head.data.length;
        }
        return state.buffer[0].length;
      }
      return state.length;
    }
  }
});

// node_modules/duplexify/index.js
var require_duplexify = __commonJS({
  "node_modules/duplexify/index.js"(exports, module) {
    init_shim();
    var stream = require_readable_browser();
    var eos = require_end_of_stream2();
    var inherits = require_inherits_browser();
    var shift = require_stream_shift();
    var SIGNAL_FLUSH = import_buffer.Buffer.from && import_buffer.Buffer.from !== Uint8Array.from ? import_buffer.Buffer.from([0]) : new import_buffer.Buffer([0]);
    var onuncork = function(self2, fn) {
      if (self2._corked)
        self2.once("uncork", fn);
      else
        fn();
    };
    var autoDestroy = function(self2, err) {
      if (self2._autoDestroy)
        self2.destroy(err);
    };
    var destroyer = function(self2, end2) {
      return function(err) {
        if (err)
          autoDestroy(self2, err.message === "premature close" ? null : err);
        else if (end2 && !self2._ended)
          self2.end();
      };
    };
    var end = function(ws, fn) {
      if (!ws)
        return fn();
      if (ws._writableState && ws._writableState.finished)
        return fn();
      if (ws._writableState)
        return ws.end(fn);
      ws.end();
      fn();
    };
    var noop = function() {
    };
    var toStreams2 = function(rs) {
      return new stream.Readable({ objectMode: true, highWaterMark: 16 }).wrap(rs);
    };
    var Duplexify = function(writable, readable, opts) {
      if (!(this instanceof Duplexify))
        return new Duplexify(writable, readable, opts);
      stream.Duplex.call(this, opts);
      this._writable = null;
      this._readable = null;
      this._readable2 = null;
      this._autoDestroy = !opts || opts.autoDestroy !== false;
      this._forwardDestroy = !opts || opts.destroy !== false;
      this._forwardEnd = !opts || opts.end !== false;
      this._corked = 1;
      this._ondrain = null;
      this._drained = false;
      this._forwarding = false;
      this._unwrite = null;
      this._unread = null;
      this._ended = false;
      this.destroyed = false;
      if (writable)
        this.setWritable(writable);
      if (readable)
        this.setReadable(readable);
    };
    inherits(Duplexify, stream.Duplex);
    Duplexify.obj = function(writable, readable, opts) {
      if (!opts)
        opts = {};
      opts.objectMode = true;
      opts.highWaterMark = 16;
      return new Duplexify(writable, readable, opts);
    };
    Duplexify.prototype.cork = function() {
      if (++this._corked === 1)
        this.emit("cork");
    };
    Duplexify.prototype.uncork = function() {
      if (this._corked && --this._corked === 0)
        this.emit("uncork");
    };
    Duplexify.prototype.setWritable = function(writable) {
      if (this._unwrite)
        this._unwrite();
      if (this.destroyed) {
        if (writable && writable.destroy)
          writable.destroy();
        return;
      }
      if (writable === null || writable === false) {
        this.end();
        return;
      }
      var self2 = this;
      var unend = eos(writable, { writable: true, readable: false }, destroyer(this, this._forwardEnd));
      var ondrain = function() {
        var ondrain2 = self2._ondrain;
        self2._ondrain = null;
        if (ondrain2)
          ondrain2();
      };
      var clear = function() {
        self2._writable.removeListener("drain", ondrain);
        unend();
      };
      if (this._unwrite)
        import_process.default.nextTick(ondrain);
      this._writable = writable;
      this._writable.on("drain", ondrain);
      this._unwrite = clear;
      this.uncork();
    };
    Duplexify.prototype.setReadable = function(readable) {
      if (this._unread)
        this._unread();
      if (this.destroyed) {
        if (readable && readable.destroy)
          readable.destroy();
        return;
      }
      if (readable === null || readable === false) {
        this.push(null);
        this.resume();
        return;
      }
      var self2 = this;
      var unend = eos(readable, { writable: false, readable: true }, destroyer(this));
      var onreadable = function() {
        self2._forward();
      };
      var onend = function() {
        self2.push(null);
      };
      var clear = function() {
        self2._readable2.removeListener("readable", onreadable);
        self2._readable2.removeListener("end", onend);
        unend();
      };
      this._drained = true;
      this._readable = readable;
      this._readable2 = readable._readableState ? readable : toStreams2(readable);
      this._readable2.on("readable", onreadable);
      this._readable2.on("end", onend);
      this._unread = clear;
      this._forward();
    };
    Duplexify.prototype._read = function() {
      this._drained = true;
      this._forward();
    };
    Duplexify.prototype._forward = function() {
      if (this._forwarding || !this._readable2 || !this._drained)
        return;
      this._forwarding = true;
      var data;
      while (this._drained && (data = shift(this._readable2)) !== null) {
        if (this.destroyed)
          continue;
        this._drained = this.push(data);
      }
      this._forwarding = false;
    };
    Duplexify.prototype.destroy = function(err, cb) {
      if (!cb)
        cb = noop;
      if (this.destroyed)
        return cb(null);
      this.destroyed = true;
      var self2 = this;
      import_process.default.nextTick(function() {
        self2._destroy(err);
        cb(null);
      });
    };
    Duplexify.prototype._destroy = function(err) {
      if (err) {
        var ondrain = this._ondrain;
        this._ondrain = null;
        if (ondrain)
          ondrain(err);
        else
          this.emit("error", err);
      }
      if (this._forwardDestroy) {
        if (this._readable && this._readable.destroy)
          this._readable.destroy();
        if (this._writable && this._writable.destroy)
          this._writable.destroy();
      }
      this.emit("close");
    };
    Duplexify.prototype._write = function(data, enc, cb) {
      if (this.destroyed)
        return;
      if (this._corked)
        return onuncork(this, this._write.bind(this, data, enc, cb));
      if (data === SIGNAL_FLUSH)
        return this._finish(cb);
      if (!this._writable)
        return cb();
      if (this._writable.write(data) === false)
        this._ondrain = cb;
      else if (!this.destroyed)
        cb();
    };
    Duplexify.prototype._finish = function(cb) {
      var self2 = this;
      this.emit("preend");
      onuncork(this, function() {
        end(self2._forwardEnd && self2._writable, function() {
          if (self2._writableState.prefinished === false)
            self2._writableState.prefinished = true;
          self2.emit("prefinish");
          onuncork(self2, cb);
        });
      });
    };
    Duplexify.prototype.end = function(data, enc, cb) {
      if (typeof data === "function")
        return this.end(null, null, data);
      if (typeof enc === "function")
        return this.end(data, null, enc);
      this._ended = true;
      if (data)
        this.write(data);
      if (!this._writableState.ending && !this._writableState.destroyed)
        this.write(SIGNAL_FLUSH);
      return stream.Writable.prototype.end.call(this, cb);
    };
    module.exports = Duplexify;
  }
});

// node_modules/mqtt/lib/connect/wx.js
var require_wx = __commonJS({
  "node_modules/mqtt/lib/connect/wx.js"(exports, module) {
    "use strict";
    init_shim();
    var { Buffer: Buffer2 } = require_buffer();
    var Transform = require_readable_browser().Transform;
    var duplexify = require_duplexify();
    var socketTask;
    var proxy;
    var stream;
    function buildProxy() {
      const proxy2 = new Transform();
      proxy2._write = function(chunk, encoding, next) {
        socketTask.send({
          data: chunk.buffer,
          success: function() {
            next();
          },
          fail: function(errMsg) {
            next(new Error(errMsg));
          }
        });
      };
      proxy2._flush = function socketEnd(done) {
        socketTask.close({
          success: function() {
            done();
          }
        });
      };
      return proxy2;
    }
    function setDefaultOpts(opts) {
      if (!opts.hostname) {
        opts.hostname = "localhost";
      }
      if (!opts.path) {
        opts.path = "/";
      }
      if (!opts.wsOptions) {
        opts.wsOptions = {};
      }
    }
    function buildUrl(opts, client) {
      const protocol = opts.protocol === "wxs" ? "wss" : "ws";
      let url = protocol + "://" + opts.hostname + opts.path;
      if (opts.port && opts.port !== 80 && opts.port !== 443) {
        url = protocol + "://" + opts.hostname + ":" + opts.port + opts.path;
      }
      if (typeof opts.transformWsUrl === "function") {
        url = opts.transformWsUrl(url, opts, client);
      }
      return url;
    }
    function bindEventHandler() {
      socketTask.onOpen(function() {
        stream.setReadable(proxy);
        stream.setWritable(proxy);
        stream.emit("connect");
      });
      socketTask.onMessage(function(res) {
        let data = res.data;
        if (data instanceof ArrayBuffer)
          data = Buffer2.from(data);
        else
          data = Buffer2.from(data, "utf8");
        proxy.push(data);
      });
      socketTask.onClose(function() {
        stream.end();
        stream.destroy();
      });
      socketTask.onError(function(res) {
        stream.destroy(new Error(res.errMsg));
      });
    }
    function buildStream(client, opts) {
      opts.hostname = opts.hostname || opts.host;
      if (!opts.hostname) {
        throw new Error("Could not determine host. Specify host manually.");
      }
      const websocketSubProtocol = opts.protocolId === "MQIsdp" && opts.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
      setDefaultOpts(opts);
      const url = buildUrl(opts, client);
      socketTask = wx.connectSocket({
        url,
        protocols: [websocketSubProtocol]
      });
      proxy = buildProxy();
      stream = duplexify.obj();
      stream._destroy = function(err, cb) {
        socketTask.close({
          success: function() {
            cb && cb(err);
          }
        });
      };
      const destroyRef = stream.destroy;
      stream.destroy = function() {
        stream.destroy = destroyRef;
        const self2 = this;
        setTimeout(function() {
          socketTask.close({
            fail: function() {
              self2._destroy(new Error());
            }
          });
        }, 0);
      }.bind(stream);
      bindEventHandler();
      return stream;
    }
    module.exports = buildStream;
  }
});

// node_modules/mqtt/lib/connect/ali.js
var require_ali = __commonJS({
  "node_modules/mqtt/lib/connect/ali.js"(exports, module) {
    "use strict";
    init_shim();
    var { Buffer: Buffer2 } = require_buffer();
    var Transform = require_readable_browser().Transform;
    var duplexify = require_duplexify();
    var my;
    var proxy;
    var stream;
    var isInitialized = false;
    function buildProxy() {
      const proxy2 = new Transform();
      proxy2._write = function(chunk, encoding, next) {
        my.sendSocketMessage({
          data: chunk.buffer,
          success: function() {
            next();
          },
          fail: function() {
            next(new Error());
          }
        });
      };
      proxy2._flush = function socketEnd(done) {
        my.closeSocket({
          success: function() {
            done();
          }
        });
      };
      return proxy2;
    }
    function setDefaultOpts(opts) {
      if (!opts.hostname) {
        opts.hostname = "localhost";
      }
      if (!opts.path) {
        opts.path = "/";
      }
      if (!opts.wsOptions) {
        opts.wsOptions = {};
      }
    }
    function buildUrl(opts, client) {
      const protocol = opts.protocol === "alis" ? "wss" : "ws";
      let url = protocol + "://" + opts.hostname + opts.path;
      if (opts.port && opts.port !== 80 && opts.port !== 443) {
        url = protocol + "://" + opts.hostname + ":" + opts.port + opts.path;
      }
      if (typeof opts.transformWsUrl === "function") {
        url = opts.transformWsUrl(url, opts, client);
      }
      return url;
    }
    function bindEventHandler() {
      if (isInitialized)
        return;
      isInitialized = true;
      my.onSocketOpen(function() {
        stream.setReadable(proxy);
        stream.setWritable(proxy);
        stream.emit("connect");
      });
      my.onSocketMessage(function(res) {
        if (typeof res.data === "string") {
          const buffer = Buffer2.from(res.data, "base64");
          proxy.push(buffer);
        } else {
          const reader = new FileReader();
          reader.addEventListener("load", function() {
            let data = reader.result;
            if (data instanceof ArrayBuffer)
              data = Buffer2.from(data);
            else
              data = Buffer2.from(data, "utf8");
            proxy.push(data);
          });
          reader.readAsArrayBuffer(res.data);
        }
      });
      my.onSocketClose(function() {
        stream.end();
        stream.destroy();
      });
      my.onSocketError(function(res) {
        stream.destroy(res);
      });
    }
    function buildStream(client, opts) {
      opts.hostname = opts.hostname || opts.host;
      if (!opts.hostname) {
        throw new Error("Could not determine host. Specify host manually.");
      }
      const websocketSubProtocol = opts.protocolId === "MQIsdp" && opts.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
      setDefaultOpts(opts);
      const url = buildUrl(opts, client);
      my = opts.my;
      my.connectSocket({
        url,
        protocols: websocketSubProtocol
      });
      proxy = buildProxy();
      stream = duplexify.obj();
      bindEventHandler();
      return stream;
    }
    module.exports = buildStream;
  }
});

// node_modules/mqtt/node_modules/ws/browser.js
var require_browser3 = __commonJS({
  "node_modules/mqtt/node_modules/ws/browser.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/mqtt/lib/connect/ws.js
var require_ws = __commonJS({
  "node_modules/mqtt/lib/connect/ws.js"(exports, module) {
    "use strict";
    init_shim();
    var { Buffer: Buffer2 } = require_buffer();
    var WS = require_browser3();
    var debug = require_browser2()("mqttjs:ws");
    var duplexify = require_duplexify();
    var Transform = require_readable_browser().Transform;
    var WSS_OPTIONS = [
      "rejectUnauthorized",
      "ca",
      "cert",
      "key",
      "pfx",
      "passphrase"
    ];
    var IS_BROWSER = typeof import_process.default !== "undefined" && import_process.default.title === "browser" || typeof __webpack_require__ === "function";
    function buildUrl(opts, client) {
      let url = opts.protocol + "://" + opts.hostname + ":" + opts.port + opts.path;
      if (typeof opts.transformWsUrl === "function") {
        url = opts.transformWsUrl(url, opts, client);
      }
      return url;
    }
    function setDefaultOpts(opts) {
      const options = opts;
      if (!opts.hostname) {
        options.hostname = "localhost";
      }
      if (!opts.port) {
        if (opts.protocol === "wss") {
          options.port = 443;
        } else {
          options.port = 80;
        }
      }
      if (!opts.path) {
        options.path = "/";
      }
      if (!opts.wsOptions) {
        options.wsOptions = {};
      }
      if (!IS_BROWSER && opts.protocol === "wss") {
        WSS_OPTIONS.forEach(function(prop) {
          if (Object.prototype.hasOwnProperty.call(opts, prop) && !Object.prototype.hasOwnProperty.call(opts.wsOptions, prop)) {
            options.wsOptions[prop] = opts[prop];
          }
        });
      }
      return options;
    }
    function setDefaultBrowserOpts(opts) {
      const options = setDefaultOpts(opts);
      if (!options.hostname) {
        options.hostname = options.host;
      }
      if (!options.hostname) {
        if (typeof document === "undefined") {
          throw new Error("Could not determine host. Specify host manually.");
        }
        const parsed = new URL(document.URL);
        options.hostname = parsed.hostname;
        if (!options.port) {
          options.port = parsed.port;
        }
      }
      if (options.objectMode === void 0) {
        options.objectMode = !(options.binary === true || options.binary === void 0);
      }
      return options;
    }
    function createWebSocket(client, url, opts) {
      debug("createWebSocket");
      debug("protocol: " + opts.protocolId + " " + opts.protocolVersion);
      const websocketSubProtocol = opts.protocolId === "MQIsdp" && opts.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
      debug("creating new Websocket for url: " + url + " and protocol: " + websocketSubProtocol);
      const socket = new WS(url, [websocketSubProtocol], opts.wsOptions);
      return socket;
    }
    function createBrowserWebSocket(client, opts) {
      const websocketSubProtocol = opts.protocolId === "MQIsdp" && opts.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
      const url = buildUrl(opts, client);
      const socket = new WebSocket(url, [websocketSubProtocol]);
      socket.binaryType = "arraybuffer";
      return socket;
    }
    function streamBuilder(client, opts) {
      debug("streamBuilder");
      const options = setDefaultOpts(opts);
      const url = buildUrl(options, client);
      const socket = createWebSocket(client, url, options);
      const webSocketStream = WS.createWebSocketStream(socket, options.wsOptions);
      webSocketStream.url = url;
      socket.on("close", () => {
        webSocketStream.destroy();
      });
      return webSocketStream;
    }
    function browserStreamBuilder(client, opts) {
      debug("browserStreamBuilder");
      let stream;
      const options = setDefaultBrowserOpts(opts);
      const bufferSize = options.browserBufferSize || 1024 * 512;
      const bufferTimeout = opts.browserBufferTimeout || 1e3;
      const coerceToBuffer = !opts.objectMode;
      const socket = createBrowserWebSocket(client, opts);
      const proxy = buildProxy(opts, socketWriteBrowser, socketEndBrowser);
      if (!opts.objectMode) {
        proxy._writev = writev;
      }
      proxy.on("close", () => {
        socket.close();
      });
      const eventListenerSupport = typeof socket.addEventListener !== "undefined";
      if (socket.readyState === socket.OPEN) {
        stream = proxy;
      } else {
        stream = stream = duplexify(void 0, void 0, opts);
        if (!opts.objectMode) {
          stream._writev = writev;
        }
        if (eventListenerSupport) {
          socket.addEventListener("open", onopen);
        } else {
          socket.onopen = onopen;
        }
      }
      stream.socket = socket;
      if (eventListenerSupport) {
        socket.addEventListener("close", onclose);
        socket.addEventListener("error", onerror);
        socket.addEventListener("message", onmessage);
      } else {
        socket.onclose = onclose;
        socket.onerror = onerror;
        socket.onmessage = onmessage;
      }
      function buildProxy(options2, socketWrite, socketEnd) {
        const proxy2 = new Transform({
          objectModeMode: options2.objectMode
        });
        proxy2._write = socketWrite;
        proxy2._flush = socketEnd;
        return proxy2;
      }
      function onopen() {
        stream.setReadable(proxy);
        stream.setWritable(proxy);
        stream.emit("connect");
      }
      function onclose() {
        stream.end();
        stream.destroy();
      }
      function onerror(err) {
        stream.destroy(err);
      }
      function onmessage(event) {
        let data = event.data;
        if (data instanceof ArrayBuffer)
          data = Buffer2.from(data);
        else
          data = Buffer2.from(data, "utf8");
        proxy.push(data);
      }
      function writev(chunks, cb) {
        const buffers = new Array(chunks.length);
        for (let i = 0; i < chunks.length; i++) {
          if (typeof chunks[i].chunk === "string") {
            buffers[i] = Buffer2.from(chunks[i], "utf8");
          } else {
            buffers[i] = chunks[i].chunk;
          }
        }
        this._write(Buffer2.concat(buffers), "binary", cb);
      }
      function socketWriteBrowser(chunk, enc, next) {
        if (socket.bufferedAmount > bufferSize) {
          setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next);
        }
        if (coerceToBuffer && typeof chunk === "string") {
          chunk = Buffer2.from(chunk, "utf8");
        }
        try {
          socket.send(chunk);
        } catch (err) {
          return next(err);
        }
        next();
      }
      function socketEndBrowser(done) {
        socket.close();
        done();
      }
      return stream;
    }
    if (IS_BROWSER) {
      module.exports = browserStreamBuilder;
    } else {
      module.exports = streamBuilder;
    }
  }
});

// node_modules/mqtt/lib/connect/index.js
var require_connect = __commonJS({
  "node_modules/mqtt/lib/connect/index.js"(exports, module) {
    init_shim();
    var MqttClient = require_client();
    var Store = require_store();
    var url = (init_url(), __toCommonJS(url_exports));
    var xtend = require_immutable();
    var debug = require_browser2()("mqttjs");
    var protocols = {};
    if (typeof import_process.default !== "undefined" && import_process.default.title !== "browser" || typeof __webpack_require__ !== "function") {
      protocols.mqtt = require_tcp();
      protocols.tcp = require_tcp();
      protocols.ssl = require_tls();
      protocols.tls = require_tls();
      protocols.mqtts = require_tls();
    } else {
      protocols.wx = require_wx();
      protocols.wxs = require_wx();
      protocols.ali = require_ali();
      protocols.alis = require_ali();
    }
    protocols.ws = require_ws();
    protocols.wss = require_ws();
    function parseAuthOptions(opts) {
      let matches;
      if (opts.auth) {
        matches = opts.auth.match(/^(.+):(.+)$/);
        if (matches) {
          opts.username = matches[1];
          opts.password = matches[2];
        } else {
          opts.username = opts.auth;
        }
      }
    }
    function connect(brokerUrl, opts) {
      debug("connecting to an MQTT broker...");
      if (typeof brokerUrl === "object" && !opts) {
        opts = brokerUrl;
        brokerUrl = null;
      }
      opts = opts || {};
      if (brokerUrl) {
        const parsed = url.parse(brokerUrl, true);
        if (parsed.port != null) {
          parsed.port = Number(parsed.port);
        }
        opts = xtend(parsed, opts);
        if (opts.protocol === null) {
          throw new Error("Missing protocol");
        }
        opts.protocol = opts.protocol.replace(/:$/, "");
      }
      parseAuthOptions(opts);
      if (opts.query && typeof opts.query.clientId === "string") {
        opts.clientId = opts.query.clientId;
      }
      if (opts.cert && opts.key) {
        if (opts.protocol) {
          if (["mqtts", "wss", "wxs", "alis"].indexOf(opts.protocol) === -1) {
            switch (opts.protocol) {
              case "mqtt":
                opts.protocol = "mqtts";
                break;
              case "ws":
                opts.protocol = "wss";
                break;
              case "wx":
                opts.protocol = "wxs";
                break;
              case "ali":
                opts.protocol = "alis";
                break;
              default:
                throw new Error('Unknown protocol for secure connection: "' + opts.protocol + '"!');
            }
          }
        } else {
          throw new Error("Missing secure protocol key");
        }
      }
      if (!protocols[opts.protocol]) {
        const isSecure = ["mqtts", "wss"].indexOf(opts.protocol) !== -1;
        opts.protocol = [
          "mqtt",
          "mqtts",
          "ws",
          "wss",
          "wx",
          "wxs",
          "ali",
          "alis"
        ].filter(function(key, index) {
          if (isSecure && index % 2 === 0) {
            return false;
          }
          return typeof protocols[key] === "function";
        })[0];
      }
      if (opts.clean === false && !opts.clientId) {
        throw new Error("Missing clientId for unclean clients");
      }
      if (opts.protocol) {
        opts.defaultProtocol = opts.protocol;
      }
      function wrapper(client2) {
        if (opts.servers) {
          if (!client2._reconnectCount || client2._reconnectCount === opts.servers.length) {
            client2._reconnectCount = 0;
          }
          opts.host = opts.servers[client2._reconnectCount].host;
          opts.port = opts.servers[client2._reconnectCount].port;
          opts.protocol = !opts.servers[client2._reconnectCount].protocol ? opts.defaultProtocol : opts.servers[client2._reconnectCount].protocol;
          opts.hostname = opts.host;
          client2._reconnectCount++;
        }
        debug("calling streambuilder for", opts.protocol);
        return protocols[opts.protocol](client2, opts);
      }
      const client = new MqttClient(wrapper, opts);
      client.on("error", function() {
      });
      return client;
    }
    module.exports = connect;
    module.exports.connect = connect;
    module.exports.MqttClient = MqttClient;
    module.exports.Store = Store;
  }
});
export default require_connect();
/*! Bundled license information:

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

punycode/punycode.js:
  (*! https://mths.be/punycode v1.4.1 by @mathias *)
*/
//# sourceMappingURL=mqtt.js.map
